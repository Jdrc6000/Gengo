--- main.py ---
from time import time
from src.frontend.lexer import Lexer
from src.frontend.parser import Parser
from src.semantic.analyser import Analyser, SymbolTable
from src.optimiser.optimiser import Optimiser
from src.ir.generator import IRGenerator
from src.runtime.regalloc import linear_scan_allocate
from src.runtime.vm import VM
from src.ir.operands import Reg, Imm
from src.exceptions import *
def fmt(x):
    if isinstance(x, Reg):
        return f"r{x.id}"
    if isinstance(x, Imm):
        return x.value
    return x
def token_length(token):
    if token is None:
        return 1
    if hasattr(token, 'id') and isinstance(token.id, str):
        return len(token.id)
    if hasattr(token, 'value') and token.value is not None:
        return len(str(token.value))
    return 1
code = """
fn check(a) {
    if a == 1 {
        return "a is 1"
    } else if a == 2 {
        return "a Is 2"
    } else if a == 3 {
        return "a is 3"
    } else {
        return "idk what a is"
    }
}
result = check(2)
i = 0
while i < result.len() {
    print(result.at(i).lower())
    i = i + 1
}
println()
nums = [1, 2, 3, 4, 5]
i = 0
while i < nums.len() {
    print(nums.at(i))
    i = i + 1
}
"""
num_regs = 1024
start = time()
try:
    lexer = Lexer(code)
    tokens = lexer.get_tokens()
    print(tokens)
    parser = Parser(tokens)
    tree = parser.parse()
    parser.dump(tree)
    symbol_table = SymbolTable()
    semantic_analysis = Analyser(symbol_table)
    semantic_analysis.analyse(tree)
    optimiser = Optimiser()
    tree = optimiser.optimise(tree)
    parser.dump(tree)
    ir_generator = IRGenerator()
    ir_generator.generate(tree)
    ir_generator.ir.dump()
    allocated = linear_scan_allocate(ir_generator.ir.code, num_regs=num_regs)
    for i, instr in enumerate(allocated):
        print(f"realloc{i} {instr.op} {fmt(instr.a)} {fmt(instr.b)} {fmt(instr.c)}")
    start_vm = time()
    vm = VM(num_regs=num_regs)
    vm.code = allocated
    start_ip = vm.find_label("__main__")
    vm.ip = start_ip
    vm.run(allocated)
    vm.dump_regs()
    print(f"took {time() - start} secs")
    print(f"took {time() - start_vm} secs to run vm")
except CompileError as e:
    print(format_diagnostic(
        source=code,
        filename="<string>",
        line=e.line or 1,
        column=e.column or 1,
        message=e.message,
        level=e.level,
        highlight_length=token_length(e.token)
    ))
    exit(1)
except RuntimeError as e:
    print(format_diagnostic(
        source=code,
        filename="<string>",
        line=e.line or 1,
        column=e.column or 1,
        message=e.message,
        highlight_length=token_length(e.token)
    ))
    exit(1)
except IndexError as e:
    raise RuntimeError(f"number of regs prolly too low: {e}") from e
except Exception as e:
    raise RuntimeError(f"couldnt even begin to tell you where this came from: {e}") from e

--- src/exceptions.py ---
from dataclasses import dataclass
from typing import Optional
from src.frontend.token import Token
def format_diagnostic(
    source: str,
    filename: str,
    line: int,
    column: int,
    message: str,
    level: str = "error",
    highlight_length: int = 1
) -> str:
    lines = source.splitlines()
    if not (1 <= line <= len(lines)):
        return f"{filename}:{line}:{column}: {level}: {message} (line out of range)"
    lineno = line - 1
    bad_line = lines[lineno].rstrip()
    MAX = 72
    start = max(0, column - 1 - MAX // 2)
    end = min(len(bad_line), start + MAX)
    snippet = bad_line[start:end]
    caret_pos = (column - 1) - start
    color = {
        "error": "\033[91m",
        "warning": "\033[93m",
        "note": "\033[94m",
    }.get(level, "")
    reset = "\033[0m"
    return (
        f"{filename}:{line}:{column}: {color}{level}:{reset} {message}\n"
        f"   {line:3} │ {snippet}\n"
        f"       │ {' ' * caret_pos}{'^' * highlight_length}\n"
    )
@dataclass
class CompileError(Exception):
    message: str
    token: Optional[Token] = None
    line: Optional[int] = None
    column: Optional[int] = None
    level: str = "error"
    def __post_init__(self):
        if self.token:
            self.line = self.line or self.token.line
            self.column = self.column or self.token.column
    def __str__(self) -> str:
        loc = ""
        if self.line is not None:
            loc = f"[{self.line}:{self.column or '?'}] "
        return f"{self.level.upper()} {loc}{self.message}"
@dataclass
class RuntimeError(Exception):
    message: str
    ip: Optional[int] = None
    instruction: Optional[str] = None
    line: Optional[int] = None
    column: Optional[int] = None
    def __str__(self) -> str:
        loc = ""
        if self.ip is not None:
            loc = f" at ip={self.ip}"
        if self.line is not None:
            loc += f" (source:{self.line}:{self.column or '?'})"
        return f"RUNTIME ERROR{loc}: {self.message}"
class LexerError(CompileError): pass
class ParseError(CompileError): pass
class SemanticError(CompileError): pass
class TypeError(CompileError): pass
class UndefinedVariableError(SemanticError): pass
class UnreachableCodeWarning(CompileError): pass
class DivisionByZeroError(RuntimeError): pass
class TypeMismatchError(RuntimeError): pass
class IndexOutOfBoundsError(RuntimeError): pass
class InvalidArgumentError(RuntimeError): pass
class StackUnderflowError(RuntimeError): pass
class UnknownOpcodeError(RuntimeError): pass
class LabelNotFoundError(RuntimeError): pass

--- src/frontend/ast_nodes.py ---
from dataclasses import dataclass, field
from typing import List as TypingList, Optional, Any, Union, Tuple
@dataclass
class AST:
    inferred_type = None
@dataclass
class Module(AST):
    body: TypingList[AST]
    line: int = 0
    column: int = 0
@dataclass
class Block(AST):
    statements: TypingList[AST]
    line: int = 0
    column: int = 0
    def __iter__(self):
        return iter(self.statements)
@dataclass
class Call(AST):
    func: AST
    args: TypingList[AST]
    line: int = 0
    column: int = 0
@dataclass
class Assign(AST):
    target: AST
    value: AST
    line: int = 0
    column: int = 0
@dataclass
class Expr(AST):
    value: AST
    line: int = 0
    column: int = 0
@dataclass
class Name(AST):
    id: str
    line: int = 0
    column: int = 0
@dataclass
class Constant(AST):
    value: Any
    line: int = 0
    column: int = 0
@dataclass
class BinOp(AST):
    left: AST
    op: str
    right: AST
    line: int = 0
    column: int = 0
@dataclass
class UnOp(AST):
    op: str
    operand: AST
    line: int = 0
    column: int = 0
@dataclass
class If(AST):
    test: AST
    body: Block
    orelse: Optional[Union[Block, "If"]] = None
    line: int = 0
    column: int = 0
@dataclass
class Compare(AST):
    left: AST
    ops: TypingList[str]
    comparators: TypingList[AST]
    line: int = 0
    column: int = 0
@dataclass
class FunctionDef(AST):
    name: str
    args: TypingList[str]
    body: TypingList[AST]
    line: int = 0
    column: int = 0
@dataclass
class Return(AST):
    value: Optional[AST] = None
    line: int = 0
    column: int = 0
@dataclass
class While(AST):
    test: AST
    body: TypingList[AST]
    line: int = 0
    column: int = 0
@dataclass
class For(AST):
    target: Name
    start: AST
    end: AST
    body: TypingList[AST]
    line: int = 0
    column: int = 0
@dataclass
class List(AST):
    elements: TypingList[AST]
    line: int = 0
    column: int = 0
@dataclass
class Attribute(AST):
    obj: AST
    attr: str
    line: int = 0
    column: int = 0
@dataclass
class MethodCall(AST):
    obj: AST
    method: str
    args: TypingList[AST]
    line: int = 0
    column: int = 0

--- src/frontend/lexer.py ---
from src.frontend.token_maps import *
from src.frontend.token import Token
from src.frontend.token_types import *
from src.exceptions import *
class Lexer():
    def __init__(self, text):
        self.text = text
        self.line = 1
        self.col = 1
        self.pos = 0
        self.current_char = self.text[self.pos] if self.text else None
    def advance(self):
        if self.current_char == "\n":
            self.line += 1
            self.col = 1
        else:
            self.col += 1
        self.pos += 1
        if self.pos < len(self.text):
            self.current_char = self.text[self.pos]
        else:
            self.current_char = None
    def skip_whitespace(self):
        while self.current_char and self.current_char in " \t":
            self.advance()
    def peek(self):
        if self.pos + 1 < len(self.text):
            return self.text[self.pos + 1]
        return None
    def number(self):
        start_line = self.line
        start_col = self.col
        num_str = ""
        dot_count = 0
        while self.current_char and self.current_char in "0123456789.":
            if self.current_char == ".":
                dot_count += 1
                if dot_count == 1:
                    next_char = self.peek()
                    if next_char == ".":
                        break
                    if next_char is None or not next_char.isdigit():
                        break
            num_str += self.current_char
            self.advance()
        if not num_str:
            raise LexerError(
                message=f"Illegal character: {self.current_char!r}",
                token=Token(TokenType.ILLEGAL, self.current_char, self.line, self.col)
            )
        if dot_count == 0:
            return Token(TokenType.INT, int(num_str), line=start_line, column=start_col)
        elif dot_count == 1 and num_str[-1] != ".":
            return Token(TokenType.FLOAT, float(num_str), line=start_line, column=start_col)
        else:
            raise LexerError(
                message=f"Illegal character: {self.current_char!r}",
                token=Token(TokenType.ILLEGAL, self.current_char, self.line, self.col)
            )
    def string(self):
        start_line = self.line
        start_col = self.col
        string_val = ""
        quote_char = self.current_char
        self.advance()
        while self.current_char and self.current_char != quote_char:
            string_val += self.current_char
            self.advance()
        self.advance()
        return Token(TokenType.STRING, string_val, line=start_line, column=start_col)
    def name(self):
        start_line = self.line
        start_col = self.col
        name_str = ""
        while self.current_char and (self.current_char.isalnum() or self.current_char == "_"):
            name_str += self.current_char
            self.advance()
        tok_type = KEYWORDS.get(name_str, TokenType.NAME)
        value = name_str if tok_type == TokenType.NAME else None
        tok = Token(tok_type, value, line=start_line, column=start_col)
        return tok
    def get_tokens(self):
        tokens = []
        while self.current_char is not None:
            if self.current_char == "\n":
                self.advance()
                continue
            elif self.current_char.isspace():
                self.skip_whitespace()
            elif self.current_char == "!" and self.peek() == "=":
                start_line = self.line
                start_col = self.col
                self.advance()
                self.advance()
                tokens.append(Token(TokenType.NE, line=start_line, column=start_col))
            elif self.current_char == "=" and self.peek() == "=":
                start_line = self.line
                start_col = self.col
                self.advance()
                self.advance()
                tokens.append(Token(TokenType.EE, line=start_line, column=start_col))
            elif self.current_char == "<" and self.peek() == "=":
                start_line = self.line
                start_col = self.col
                self.advance()
                self.advance()
                tokens.append(Token(TokenType.LE, line=start_line, column=start_col))
            elif self.current_char == ">" and self.peek() == "=":
                start_line = self.line
                start_col = self.col
                self.advance()
                self.advance()
                tokens.append(Token(TokenType.GE, line=start_line, column=start_col))
            elif self.current_char == "." and self.peek() == ".":
                start_line = self.line
                start_col = self.col
                self.advance()
                self.advance()
                tokens.append(Token(TokenType.RANGE, line=start_line, column=start_col))
            elif self.current_char == ">":
                start_line = self.line
                start_col = self.col
                self.advance()
                tokens.append(Token(TokenType.GREATER, line=start_line, column=start_col))
            elif self.current_char == "<":
                start_line = self.line
                start_col = self.col
                self.advance()
                tokens.append(Token(TokenType.LESS, line=start_line, column=start_col))
            elif self.current_char in SINGLE_CHAR_TOKENS:
                start_line = self.line
                start_col = self.col
                tok_type = SINGLE_CHAR_TOKENS[self.current_char]
                tokens.append(Token(tok_type, line=start_line, column=start_col))
                self.advance()
            elif self.current_char.isdigit():
                tokens.append(self.number())
            elif self.current_char.isalpha() or self.current_char == "_":
                tokens.append(self.name())
            elif self.current_char in "\"'":
                tokens.append(self.string())
            else:
                raise LexerError(
                    message=f"Illegal character: {self.current_char!r}",
                    token=Token(TokenType.ILLEGAL, self.current_char, self.line, self.col)
                )
        tokens.append(Token(TokenType.EOF))
        return tokens

--- src/frontend/parser.py ---
from src.frontend.token_maps import CMP_TOK_TO_STR
from src.frontend.token_types import *
from src.frontend.ast_nodes import *
from src.frontend.token import Token
from src.exceptions import *
class Parser():
    def __init__(self, tokens):
        self.tokens = tokens
        self.pos = 0
        self.current_token = self.tokens[self.pos]
    def advance(self):
        self.pos += 1
        if self.pos < len(self.tokens):
            self.current_token = self.tokens[self.pos]
        else:
            self.current_token = Token(TokenType.EOF)
    def peek(self):
        if self.pos + 1 < len(self.tokens):
            return self.tokens[self.pos + 1]
        return None
    def _parse_arg_list(self):
        args = []
        if self.current_token.type != TokenType.RPAREN:
            while True:
                args.append(self.parse_expr())
                if self.current_token.type == TokenType.COMMA:
                    self.advance()
                elif self.current_token.type == TokenType.RPAREN:
                    break
                else:
                    raise ParseError(
                        message="Expected ',' or ')' in argument list",
                        line=self.current_token.line,
                        column=self.current_token.column
                    )
        self.advance()
        return args
    def parse(self):
        body = []
        while self.current_token.type != TokenType.EOF:
            if self.current_token.type == TokenType.EOF:
                break
            body.append(self.statement())
        return Module(body)
    def statement(self):
        if self.current_token.type == TokenType.PRINT:
            return self.parse_print()
        elif self.current_token.type == TokenType.LBRACE:
            return self.parse_block()
        elif self.current_token.type == TokenType.IF:
            return self.parse_if()
        elif self.current_token.type == TokenType.NAME:
            if self.peek() and self.peek().type == TokenType.LPAREN:
                return self.parse_call()
            elif self.peek() and self.peek().type == TokenType.EQ:
                return self.parse_assign()
            else:
                return Expr(
                    value=Name(
                        id=self.current_token.value,
                        line=self.current_token.line,
                        column=self.current_token.column
                    ),
                    line=self.current_token.line,
                    column=self.current_token.column
                )
        elif self.current_token.type == TokenType.FN:
            return self.parse_function()
        elif self.current_token.type == TokenType.WHILE:
            return self.parse_while()
        elif self.current_token.type == TokenType.FOR:
            return self.parse_for()
        elif self.current_token.type == TokenType.RETURN:
            return self.parse_return()
        else:
            return Expr(
                value=self.parse_expr(),
                line=self.current_token.line,
                column=self.current_token.column
            )
    def parse_primary(self):
        tok = self.current_token
        if tok.type in (TokenType.INT, TokenType.FLOAT, TokenType.STRING):
            self.advance()
            node = Constant(
                value=tok.value,
                line=tok.line,
                column=tok.column
            )
        elif tok.type == TokenType.NAME:
            self.advance()
            node = Name(
                id=tok.value,
                line=tok.line,
                column=tok.column
            )
            if self.current_token.type == TokenType.LPAREN:
                self.advance()
                args = self._parse_arg_list()
                node = Call(
                    func=node,
                    args=args,
                    line=tok.line,
                    column=tok.column
                )
        elif tok.type == TokenType.LPAREN:
            self.advance()
            if self.current_token.type == TokenType.RPAREN:
                node = Constant(None)
            else:
                node = self.parse_expr()
            if self.current_token.type != TokenType.RPAREN:
                raise ParseError(
                    message=f"Expected ')' after expression",
                    line=self.current_token.line,
                    column=self.current_token.column
                )
            self.advance()
        elif tok.type == TokenType.TRUE:
            self.advance()
            node = Constant(
                value=True,
                line=tok.line,
                column=tok.column
            )
        elif tok.type == TokenType.FALSE:
            self.advance()
            node = Constant(
                value=False,
                line=tok.line,
                column=tok.column
            )
        elif tok.type == TokenType.LBRACKET:
            self.advance()
            elements = []
            if self.current_token.type != TokenType.RBRACKET:
                while True:
                    elements.append(self.parse_expr())
                    if self.current_token.type == TokenType.COMMA:
                        self.advance()
                    elif self.current_token.type == TokenType.RBRACKET:
                        break
                    else:
                        raise ParseError(
                            message="Expected ',' or ']' in list literal",
                            line=self.current_token.line,
                            column=self.current_token.column
                        )
            self.advance()
            node = List(
                elements=elements,
                line=tok.line,
                column=tok.column
            )
        else:
            raise ParseError(
                message=f"Unexpected token: {tok}",
                line=self.current_token.line,
                column=self.current_token.column
            )
        while self.current_token.type == TokenType.DOT:
            dot_line = self.current_token.line
            dot_col = self.current_token.column
            self.advance()
            if self.current_token.type != TokenType.NAME:
                raise ParseError(
                    message="Expected attribute or method name after '.'",
                    line=self.current_token.line,
                    column=self.current_token.column
                )
            attr_tok = self.current_token
            self.advance()
            if self.current_token.type == TokenType.LPAREN:
                self.advance()
                args = self._parse_arg_list()
                node = MethodCall(
                    obj=node,
                    method=attr_tok.value,
                    args=args,
                    line=dot_line,
                    column=dot_col
                )
            else:
                node = Attribute(
                    obj=node,
                    attr=attr_tok.value,
                    line=dot_line,
                    column=dot_col
                )
        return node
    def parse_assign(self):
        name_token = self.current_token
        self.advance()
        if self.current_token.type != TokenType.EQ:
            raise ParseError(
                message=f"Expected '=' after variable name",
                line=name_token.line,
                column=name_token.column
            )
        self.advance()
        value_node = self.parse_expr()
        return Assign(
            target=Name(
                id=name_token.value,
                line=name_token.line,
                column=name_token.column
            ),
            value=value_node,
            line=name_token.line,
            column=name_token.column
        )
    def parse_comparison(self):
        comparision_token = self.current_token
        left = self.parse_binop()
        ops = []
        comparators = []
        while self.current_token.type in (
            TokenType.EE, TokenType.NE, TokenType.LESS,
            TokenType.GREATER, TokenType.LE, TokenType.GE
        ):
            op_str = CMP_TOK_TO_STR[self.current_token.type]
            ops.append(op_str)
            self.advance()
            comparators.append(self.parse_binop())
        if ops:
            return Compare(
                left=left,
                ops=ops,
                comparators=comparators,
                line=comparision_token.line,
                column=comparision_token.column
            )
        return left
    def parse_logic_or(self):
        left = self.parse_logic_and()
        while self.current_token.type == TokenType.OR:
            self.advance()
            right = self.parse_logic_and()
            left = BinOp(
                left=left,
                op="or",
                right=right,
                line=self.current_token.line,
                column=self.current_token.column
            )
        return left
    def parse_logic_and(self):
        left = self.parse_comparison()
        while self.current_token.type == TokenType.AND:
            self.advance()
            right = self.parse_comparison()
            left = BinOp(
                left=left,
                op="and",
                right=right,
                line=self.current_token.line,
                column=self.current_token.column
            )
        return left
    def parse_expr(self):
        return self.parse_logic_or()
    def parse_binop(self, min_prec=0):
        left = self.parse_unary()
        while True:
            op_token = self.current_token
            if op_token.type in (
                TokenType.PLUS, TokenType.MINUS, TokenType.MUL,
                TokenType.DIV, TokenType.POW
            ):
                prec = self.get_precedence(op_token)
                if prec < min_prec:
                    break
                self.advance()
                right = self.parse_binop(prec+1)
                left = BinOp(
                    left=left,
                    op=self.token_to_op(op_token),
                    right=right,
                    line=self.current_token.line,
                    column=self.current_token.column
                )
            else:
                break
        return left
    def parse_unary(self):
        tok = self.current_token
        if tok.type in (TokenType.PLUS, TokenType.MINUS):
            self.advance()
            return UnOp(op=self.token_to_op(tok), operand=self.parse_unary())
        elif tok.type == TokenType.NOT:
            self.advance()
            return UnOp(
                op="not",
                operand=self.parse_unary(),
                line=tok.line,
                column=tok.column
            )
        else:
            return self.parse_primary()
    def parse_function(self):
        function_token = self.current_token
        self.advance()
        if self.current_token.type != TokenType.NAME:
            raise ParseError(
                message=f"Expected function name",
                line=function_token.line,
                column=function_token.column
            )
        func_name = self.current_token.value
        self.advance()
        if self.current_token.type != TokenType.LPAREN:
            raise ParseError(
                message=f"Expected '(' after function name",
                line=self.current_token.line,
                column=self.current_token.column
            )
        self.advance()
        args = []
        if self.current_token.type != TokenType.RPAREN:
            while True:
                if self.current_token.type != TokenType.NAME:
                    raise ParseError(
                        message=f"Expected argument name",
                        line=self.current_token.line,
                        column=self.current_token.column
                    )
                args.append(self.current_token.value)
                self.advance()
                if self.current_token.type == TokenType.RPAREN:
                    break
                elif self.current_token.type == TokenType.COMMA:
                    self.advance()
                else:
                    raise ParseError(
                        message=f"Expected ',' or ')'",
                        line=self.current_token.line,
                        column=self.current_token.column
                    )
        self.advance()
        body = self.parse_block()
        return FunctionDef(
            name=func_name,
            args=args,
            body=body,
            line=function_token.line,
            column=function_token.column
        )
    def parse_if(self):
        if_token = self.current_token
        self.advance()
        test = self.parse_expr()
        body = self.parse_block()
        orelse = None
        if self.current_token.type == TokenType.ELSE:
            self.advance()
            if self.current_token.type == TokenType.IF:
                orelse = [self.parse_if()]
            else:
                if self.current_token.type != TokenType.LBRACE:
                    raise ParseError(
                        message="Expected '{' or 'if' after 'else'",
                        line=self.current_token.line,
                        column=self.current_token.column
                    )
                orelse = self.parse_block()
        return If(
            test=test,
            body=body,
            orelse=orelse,
            line=if_token.line,
            column=if_token.column
        )
    def parse_while(self):
        while_token = self.current_token
        self.advance()
        test = self.parse_expr()
        body = self.parse_block()
        return While(
            test=test,
            body=body,
            line=while_token.line,
            column=while_token.column
        )
    def parse_call(self):
        func_token = self.current_token
        self.advance()
        if self.current_token.type != TokenType.LPAREN:
            raise ParseError(
                message=f"Expected '(' in function call",
                line=self.current_token.line,
                column=self.current_token.column
            )
        self.advance()
        args = []
        if self.current_token.type != TokenType.RPAREN:
            while True:
                args.append(self.parse_expr())
                if self.current_token.type == TokenType.COMMA:
                    self.advance()
                elif self.current_token.type == TokenType.RPAREN:
                    break
                else:
                    raise ParseError(
                        message="Expected ',' or ')' in argument list",
                        line=self.current_token.line,
                        column=self.current_token.column
                    )
        self.advance()
        return Call(
            func=Name(
                id=func_token.value,
                line=func_token.line,
                column=func_token.column
            ),
            args=args,
            line=func_token.line,
            column=func_token.column
        )
    def parse_for(self):
        for_token = self.current_token
        self.advance()
        if self.current_token.type != TokenType.NAME:
            raise ParseError(
                message=f"Expected loop variable name",
                line=self.current_token.line,
                column=self.current_token.column
            )
        loop_var = Name(
            id=self.current_token.value,
            line=self.current_token.line,
            column=self.current_token.column
        )
        self.advance()
        if self.current_token.type != TokenType.IN:
            raise ParseError(
                message=f"Expected 'in' in for loop",
                line=self.current_token.line,
                column=self.current_token.column
            )
        self.advance()
        start = self.parse_expr()
        if self.current_token.type != TokenType.RANGE:
            raise ParseError(
                message=f"Expected '..' in for loop",
                line=self.current_token.line,
                column=self.current_token.column
            )
        self.advance()
        end = self.parse_expr()
        body = self.parse_block()
        return For(
            target=loop_var,
            start=start,
            end=end,
            body=body,
            line=for_token.line,
            column=for_token.column
        )
    def parse_return(self):
        return_token = self.current_token
        self.advance()
        value = self.parse_expr()
        return Return(
            value=value,
            line=return_token.line,
            column=return_token.column
        )
    def parse_block(self):
        block_token = self.current_token
        if self.current_token.type != TokenType.LBRACE:
            raise ParseError(
                message="Expected '{' to start block",
                line=self.current_token.line,
                column=self.current_token.column
            )
        self.advance()
        body = []
        while self.current_token.type not in (TokenType.RBRACE, TokenType.EOF):
            stmt = self.statement()
            if stmt is not None:
                body.append(stmt)
        if self.current_token.type != TokenType.RBRACE:
            raise ParseError(
                message="Expected '}' to close block",
                line=self.current_token.line,
                column=self.current_token.column
            )
        self.advance()
        return Block(
            statements=body,
            line=block_token.line,
            column=block_token.column
        )
    def token_to_op(self, token):
        mapping = {
            TokenType.PLUS: "+",
            TokenType.MINUS: "-",
            TokenType.MUL: "*",
            TokenType.DIV: "/",
            TokenType.POW: "^"
        }
        return mapping[token.type]
    def get_precedence(self, token):
        prec = {
            TokenType.PLUS: 1,
            TokenType.MINUS: 1,
            TokenType.MUL: 2,
            TokenType.DIV: 2,
            TokenType.POW: 3
        }
        return prec[token.type]
    def dump(self, node, indent=0):
        pad = "  " * indent
        if isinstance(node, Module):
            print(f"{pad}Module")
            for stmt in node.body:
                self.dump(stmt, indent + 1)
        elif isinstance(node, Expr):
            print(f"{pad}Expr")
            self.dump(node.value, indent + 1)
        elif isinstance(node, Call):
            print(f"{pad}Call")
            self.dump(node.func, indent + 1)
            for arg in node.args:
                self.dump(arg, indent + 1)
        elif isinstance(node, Name):
            print(f"{pad}Name({node.id})")
        elif isinstance(node, Constant):
            print(f"{pad}Constant({node.value})")
        elif isinstance(node, Assign):
            print(f"{pad}Assign")
            self.dump(node.target, indent + 1)
            self.dump(node.value, indent + 1)
        elif isinstance(node, BinOp):
            print(f"{pad}BinaryOp({node.op})")
            self.dump(node.left, indent + 1)
            self.dump(node.right, indent + 1)
        elif isinstance(node, UnOp):
            print(f"{pad}UnaryOp({node.op})")
            self.dump(node.operand, indent + 1)
        elif isinstance(node, If):
            print(f"{pad}If")
            self.dump(node.test, indent + 1)
            print(f"{pad}  Body:")
            for stmt in node.body:
                self.dump(stmt, indent + 2)
            if node.orelse:
                print(f"{pad}  Else:")
                if isinstance(node.orelse, If):
                    self.dump(node.orelse, indent + 2)
                else:
                    for stmt in node.orelse:
                        self.dump(stmt, indent + 2)
        elif isinstance(node, Compare):
            print(f"{pad}Compare( {' '.join(node.ops)} )")
            self.dump(node.left, indent + 1)
            for comp in node.comparators:
                self.dump(comp, indent + 1)
        elif isinstance(node, While):
            print(f"{pad}While")
            self.dump(node.test, indent + 1)
            print(f"{pad}  Body:")
            for stmt in node.body:
                self.dump(stmt, indent + 2)
        elif isinstance(node, For):
            print(f"{pad}For({node.target.id})")
            self.dump(node.start, indent + 1)
            self.dump(node.end, indent + 1)
            print(f"{pad}  Body:")
            for stmt in node.body:
                self.dump(stmt, indent + 2)
        elif isinstance(node, Block):
            print(f"{pad}Block")
            for stmt in node:
                self.dump(stmt, indent + 1)
        elif isinstance(node, FunctionDef):
            print(f"{pad}FunctionDef({node.name})")
            print(f"{pad}  Args:")
            for arg in node.args:
                print(f"{pad}   {arg}")
            print(f"{pad}  Body:")
            for stmt in node.body:
                self.dump(stmt, indent + 2)
        elif isinstance(node, Return):
            print(f"{pad}Return")
            if node.value:
                self.dump(node.value, indent + 1)
        elif isinstance(node, List):
            print(f"{pad}List")
            for element in node.elements:
                self.dump(element, indent + 1)
        else:
            print(f"{pad}{node}")

--- src/frontend/token.py ---
from dataclasses import dataclass
from src.frontend.token_types import TokenType
from typing import Any, Optional
@dataclass
class Token:
    type: TokenType
    value: Optional[Any] = None
    line: int = 0
    column: int = 0
    def __repr__(self):
        if self.value is not None:
            return f"{self.type.name}:{self.value}"
        return f"{self.type.name}"

--- src/frontend/token_maps.py ---
from src.frontend.token_types import TokenType
KEYWORDS = {
    "if": TokenType.IF,
    "else": TokenType.ELSE,
    "and": TokenType.AND,
    "or": TokenType.OR,
    "not": TokenType.NOT,
    "true": TokenType.TRUE,
    "false": TokenType.FALSE,
    "while": TokenType.WHILE,
    "for": TokenType.FOR,
    "in": TokenType.IN,
    "fn": TokenType.FN,
    "return": TokenType.RETURN,
}
SINGLE_CHAR_TOKENS = {
    "+": TokenType.PLUS,
    "-": TokenType.MINUS,
    "*": TokenType.MUL,
    "/": TokenType.DIV,
    "^": TokenType.POW,
    "=": TokenType.EQ,
    "!": TokenType.BANG,
    "<": TokenType.LESS,
    ">": TokenType.GREATER,
    ",": TokenType.COMMA,
    ":": TokenType.COLON,
    ".": TokenType.DOT,
    "(": TokenType.LPAREN,
    ")": TokenType.RPAREN,
    "{": TokenType.LBRACE,
    "}": TokenType.RBRACE,
    "[": TokenType.LBRACKET,
    "]": TokenType.RBRACKET,
}
COMPARISIONS = {
    "EE": "EQ",
    "NE": "NE",
    "LESS": "LT",
    "GREATER": "GT",
    "LE": "LE",
    "GE": "GE"
}
BINOPS = {
    "+": "ADD",
    "-": "SUB",
    "*": "MUL",
    "/": "DIV",
    "^": "POW"
}
CMP_OP_TO_IR = {
    "==": "EQ",
    "!=": "NE",
    "<" : "LT",
    ">" : "GT",
    "<=": "LE",
    ">=": "GE"
}
CMP_TOK_TO_STR = {
    TokenType.EE: "==",
    TokenType.NE: "!=",
    TokenType.LESS: "<",
    TokenType.GREATER: ">",
    TokenType.LE: "<=",
    TokenType.GE: ">=",
}

--- src/frontend/token_types.py ---
from enum import Enum, auto
class TokenType(Enum):
    INT = auto()
    FLOAT = auto()
    STRING = auto()
    NAME = auto()
    PLUS = auto()
    MINUS = auto()
    MUL = auto()
    DIV = auto()
    POW = auto()
    EQ = auto()
    BANG = auto()
    LESS = auto()
    GREATER = auto()
    NE = auto()
    EE = auto()
    LE = auto()
    GE = auto()
    COMMA = auto()
    COLON = auto()
    EOF = auto()
    IF = auto()
    ELSE = auto()
    AND = auto()
    OR = auto()
    NOT = auto()
    TRUE = auto()
    FALSE = auto()
    FN = auto()
    WHILE = auto()
    FOR = auto()
    IN = auto()
    RANGE = auto()
    RETURN = auto()
    DOT = auto()
    LPAREN = auto()
    RPAREN = auto()
    LBRACE = auto()
    RBRACE = auto()
    ILLEGAL = auto()
    LBRACKET = auto()
    RBRACKET = auto()
    PRINT = auto()
    PRINTLN = auto()

--- src/ir/generator.py ---
from src.frontend.ast_nodes import *
from src.frontend.token_maps import *
from src.ir.ir import IR, Instr
from src.ir.operands import Imm
from src.runtime.builtins_registry import BUILTINS
class IRGenerator:
    def __init__(self):
        self.ir = IR()
    def generate(self, node):
        method = f"gen_{type(node).__name__}"
        return getattr(self, method)(node)
    def gen_Module(self, node):
        self.ir.emit("LABEL", "__main__")
        for stmt in node.body:
            if not isinstance(stmt, FunctionDef):
                self.generate(stmt)
        jmp = len(self.ir.code)
        self.ir.emit("JUMP", None)
        for stmt in node.body:
            if isinstance(stmt, FunctionDef):
                self.generate(stmt)
        self.ir.code[jmp].a = len(self.ir.code)
    def gen_Expr(self, node):
        return self.generate(node.value)
    def gen_Constant(self, node):
        r = self.ir.new_reg()
        self.ir.emit("LOAD_CONST", r, Imm(node.value))
        return r
    def gen_Name(self, node):
        r = self.ir.new_reg()
        self.ir.emit("LOAD_VAR", r, node.id)
        return r
    def gen_Assign(self, node):
        value_reg = self.generate(node.value)
        self.ir.emit("STORE_VAR", node.target.id, value_reg)
    def gen_Call(self, node):
        func_name = node.func.id
        if func_name in BUILTINS:
            arg_regs = [self.generate(a) for a in node.args]
            dest = self.ir.new_reg()
            self.ir.emit("CALL_BUILTIN", func_name, arg_regs, dest)
            return dest
        else:
            arg_regs = [self.generate(a) for a in node.args]
            dest = self.ir.new_reg()
            instr = Instr("CALL", node.func.id, dest)
            instr.arg_regs = arg_regs
            instr.param_names = []
            self.ir.code.append(instr)
            return dest
    def gen_Attribute(self, node):
        obj_reg = self.generate(node.obj)
        dest = self.ir.new_reg()
        instr = Instr("GET_ATTR", dest, obj_reg, node.attr)
        self.ir.code.append(instr)
        return dest
    def gen_MethodCall(self, node):
        obj_reg = self.generate(node.obj)
        arg_regs = [self.generate(a) for a in node.args]
        dest = self.ir.new_reg()
        instr = Instr("CALL_METHOD", dest, obj_reg, node.method)
        instr.arg_regs = arg_regs
        self.ir.code.append(instr)
        return dest
    def gen_List(self, node):
        element_regs = [self.generate(element) for element in node.elements]
        dest = self.ir.new_reg()
        instr = Instr("BUILD_LIST", dest)
        instr.arg_regs = element_regs
        self.ir.code.append(instr)
        return dest
    def gen_If(self, node):
        test = self.generate(node.test)
        jmp_false = len(self.ir.code)
        self.ir.emit("JUMP_IF_FALSE", test, None)
        for stmt in node.body:
            self.generate(stmt)
        if node.orelse:
            jmp_end = len(self.ir.code)
            self.ir.emit("JUMP", None)
            self.ir.code[jmp_false].b = len(self.ir.code)
            orelse = node.orelse
            if isinstance(orelse, (If, Block)):
                orelse = [orelse]
            for stmt in orelse:
                self.generate(stmt)
            self.ir.code[jmp_end].a = len(self.ir.code)
        else:
            self.ir.code[jmp_false].b = len(self.ir.code)
    def gen_Compare(self, node):
        left_reg = self.generate(node.left)
        result_reg = self.ir.new_reg()
        self.ir.emit("LOAD_CONST", result_reg, Imm(True))
        current_left = left_reg
        for op_str, right_ast in zip(node.ops, node.comparators):
            right_reg = self.generate(right_ast)
            cmp_reg = self.ir.new_reg()
            ir_op = CMP_OP_TO_IR[op_str]
            self.ir.emit(ir_op, cmp_reg, current_left, right_reg)
            self.ir.emit("AND", result_reg, result_reg, cmp_reg)
            current_left = right_reg
        return result_reg
    def gen_BinOp(self, node):
        if node.op in ("and", "or"):
            return self.gen_logic(node)
        left = self.generate(node.left)
        right = self.generate(node.right)
        dest = self.ir.new_reg()
        self.ir.emit(BINOPS[node.op], dest, left, right)
        return dest
    def gen_logic(self, node):
        left = self.generate(node.left)
        dest = self.ir.new_reg()
        self.ir.emit("MOVE", dest, left)
        if node.op == "and":
            jmp = len(self.ir.code)
            self.ir.emit("JUMP_IF_FALSE", dest, None)
            right = self.generate(node.right)
            self.ir.emit("MOVE", dest, right)
            self.ir.code[jmp].b = len(self.ir.code)
        else:
            jmp = len(self.ir.code)
            self.ir.emit("JUMP_IF_TRUE", dest, None)
            right = self.generate(node.right)
            self.ir.emit("MOVE", dest, right)
            self.ir.code[jmp].b = len(self.ir.code)
        return dest
    def gen_UnOp(self, node):
        src = self.generate(node.operand)
        dest = self.ir.new_reg()
        if node.op == "-":
            self.ir.emit("NEG", dest, src)
        elif node.op == "not":
            self.ir.emit("NOT", dest, src)
        else:
            self.ir.emit("MOVE", dest, src)
        return dest
    def gen_FunctionDef(self, node):
        instr = Instr("LABEL", node.name)
        instr.param_names = node.args
        self.ir.code.append(instr)
        stmts = node.body.statements if isinstance(node.body, Block) else node.body
        for stmt in stmts:
            self.generate(stmt)
        default_reg = self.ir.new_reg()
        self.ir.emit("LOAD_CONST", default_reg, Imm(0))
        self.ir.emit("RETURN", default_reg)
    def gen_Return(self, node):
        if node.value:
            reg = self.generate(node.value)
        else:
            reg = self.ir.new_reg()
            self.ir.emit("LOAD_CONST", reg, Imm(0))
        self.ir.emit("RETURN", reg)
    def gen_While(self, node):
        start_label = len(self.ir.code)
        test_reg = self.generate(node.test)
        jmp_exit = len(self.ir.code)
        self.ir.emit("JUMP_IF_FALSE", test_reg, None)
        for stmt in node.body:
            self.generate(stmt)
        self.ir.emit("JUMP", start_label)
        self.ir.code[jmp_exit].b = len(self.ir.code)
    def gen_For(self, node):
        start_reg = self.generate(node.start)
        end_reg = self.generate(node.end)
        var_reg = self.ir.new_reg()
        self.ir.emit("MOVE", var_reg, start_reg)
        self.ir.emit("STORE_VAR", node.target.id, var_reg)
        loop_start = len(self.ir.code)
        loop_var_reg = self.ir.new_reg()
        self.ir.emit("LOAD_VAR", loop_var_reg, node.target.id)
        cmp_reg = self.ir.new_reg()
        self.ir.emit("LT", cmp_reg, loop_var_reg, end_reg)
        jmp_exit = len(self.ir.code)
        self.ir.emit("JUMP_IF_FALSE", cmp_reg, None)
        for stmt in node.body:
            self.generate(stmt)
        self.ir.emit("LOAD_VAR", var_reg, node.target.id)
        one_reg = self.ir.new_reg()
        self.ir.emit("LOAD_CONST", one_reg, Imm(1))
        self.ir.emit("ADD", var_reg, var_reg, one_reg)
        self.ir.emit("STORE_VAR", node.target.id, var_reg)
        self.ir.emit("JUMP", loop_start)
        self.ir.code[jmp_exit].b = len(self.ir.code)

--- src/ir/ir.py ---
from src.ir.operands import Reg, Imm
from dataclasses import dataclass
from typing import Any, List
@dataclass
class Instr:
    op: str
    a: Reg | Imm | None = None
    b: Reg | Imm | None = None
    c: Reg | Imm | None = None
class IR:
    def __init__(self):
        self.code: List[Instr] = []
        self.reg = 0
    def new_reg(self):
        r = Reg(self.reg)
        self.reg += 1
        return r
    def emit(self, op, a=None, b=None, c=None):
        self.code.append(Instr(op, a, b, c))
    def dump(self):
        def fmt(x):
            if isinstance(x, Reg):
                return f"r{x.id}"
            if isinstance(x, Imm):
                return x.value
            return x
        for i, instr in enumerate(self.code):
            print(f"{i} {instr.op} {fmt(instr.a)} {fmt(instr.b)} {fmt(instr.c)}")

--- src/ir/operands.py ---
from dataclasses import dataclass
from typing import Any
@dataclass(frozen=True)
class Reg:
    id: int
@dataclass(frozen=True)
class Imm:
    value: Any

--- src/optimiser/optimiser.py ---
from src.optimiser.passes import ConstantFolder, DeadCodeEliminator
class Optimiser:
    def __init__(self):
        self.passes = [
            ConstantFolder(),
            DeadCodeEliminator(),
        ]
    def optimise(self, tree):
        for p in self.passes:
            tree = p.run(tree)
        return tree

--- src/optimiser/passes.py ---
from src.frontend.ast_nodes import Constant, Block
from dataclasses import FrozenInstanceError
class Pass:
    def __init__(self):
        self.visited = set()
    def run(self, node):
        if id(node) in self.visited:
            return node
        self.visited.add(id(node))
        method = f"visit_{type(node).__name__}"
        if hasattr(self, method):
            return getattr(self, method, self.generic)(node)
        else:
            return self.generic(node)
    def generic(self, node):
        method = f"visit_{type(node).__name__}"
        if hasattr(self, method):
            return getattr(self, method)(node)
        if not hasattr(node, "__dict__"):
            return node
        for field, value in vars(node).items():
            if isinstance(value, list):
                new_list = []
                for v in value:
                    result = self.run(v)
                    if isinstance(result, list):
                        new_list.extend(result)
                    else:
                        new_list.append(result)
                setattr(node, field, new_list)
            elif hasattr(value, "__dict__"):
                result = self.run(value)
                try:
                    setattr(node, field, result)
                except FrozenInstanceError:
                    pass
        return node
class ConstantFolder(Pass):
    def visit_BinOp(self, node):
        node.left = self.run(node.left)
        node.right = self.run(node.right)
        if isinstance(node.left, Constant) and isinstance(node.right, Constant):
            l = node.left.value
            r = node.right.value
            if node.op == "+": return Constant(l + r)
            if node.op == "-": return Constant(l - r)
            if node.op == "*": return Constant(l * r)
            if node.op == "/": return Constant(l / r)
            if node.op == "^": return Constant(l ** r)
            if node.op == "and": return Constant(l and r)
            if node.op == "or": return Constant(l or r)
        return node
    def visit_UnOp(self, node):
        node.operand = self.run(node.operand)
        if isinstance(node.operand, Constant):
            val = node.operand.value
            if node.op == "-":
                return Constant(-val)
            if node.op == "not":
                return Constant(not val)
        return node
    def visit_Compare(self, node):
        node.left = self.run(node.left)
        node.comparators = [self.run(c) for c in node.comparators]
        if isinstance(node.left, Constant) and all(isinstance(c, Constant) for c in node.comparators):
            values = [node.left.value] + [c.value for c in node.comparators]
            result = True
            for i, op in enumerate(node.ops):
                a, b = values[i], values[i+1]
                if op == "==":   result = result and (a == b)
                elif op == "!=": result = result and (a != b)
                elif op == "<":  result = result and (a < b)
                elif op == ">":  result = result and (a > b)
                elif op == "<=": result = result and (a <= b)
                elif op == ">=": result = result and (a >= b)
            return Constant(result)
        return node
class DeadCodeEliminator(Pass):
    def visit_If(self, node):
        node.test = self.run(node.test)
        if isinstance(node.test, Constant):
            body = node.body.statements if isinstance(node.body, Block) else node.body
            orelse = node.orelse or []
            if isinstance(orelse, Block): orelse = orelse.statements
            if node.test.value:
                return [self.run(stmt) for stmt in body]
            else:
                return [self.run(stmt) for stmt in orelse]
        node.body = [self.run(s) for s in (node.body.statements if isinstance(node.body, Block) else node.body)]
        if node.orelse:
            orelse = node.orelse.statements if isinstance(node.orelse, Block) else node.orelse
            node.orelse = [self.run(s) for s in orelse]
        return node

--- src/runtime/builtins_registry.py ---
from typing import Dict, Callable, List, TYPE_CHECKING
from src.ir.operands import Reg
if TYPE_CHECKING:
    from .vm import VM
class Builtin:
    def __init__(self, name: str, func: Callable, min_args: int = 0, max_args: int = None):
        self.name = name
        self.func = func
        self.min_args = min_args
        self.max_args = max_args or min_args
    def __call__(self, vm: VM, arg_regs: List[Reg]):
        args = [vm.regs[r.id] for r in arg_regs]
        if len(args) < self.min_args or (self.max_args is not None and len(args) > self.max_args):
            raise RuntimeError(
                message=f"Builtin '{self.name}' expected {self.min_args}-{self.max_args} args, got {len(args)}"
            )
        return self.func(vm, args)
def builtin_print(vm: VM, args: list):
    print(*args, sep=" ", end="")
def builtin_println(vm: VM, args: list):
    print(*args)
def builtin_len(vm: VM, args: list):
    if len(args) != 1:
        raise ValueError("len() takes exactly one argument")
    return len(args[0])
BUILTINS: Dict[str, Builtin] = {
    "print": Builtin("print",   builtin_print,   min_args=0, max_args=999),
    "println": Builtin("println", builtin_println, min_args=0, max_args=999),
    "len": Builtin("len",     builtin_len,     min_args=1, max_args=1),
}

--- src/runtime/methods.py ---
from typing import Any, List, Callable
import math
def _require_args(name, args, count):
    if len(args) != count:
        raise TypeError(f"'name' takes {count} argument(s), got {len(args)}")
def _list_push(list, args):
    _require_args("push", args, 1)
    list.append(args[0])
    return list
def _list_pop(list, args):
    if args:
        list.pop(int(args[0]))
    return list
def _list_join(list, args):
    sep = args[0] if args else ""
    return sep.join(str(x) for x in list)
STRING_MEMBERS = {
    "len": lambda s, args: len(s),
    "upper": lambda s, args: s.upper(),
    "lower": lambda s, args: s.lower(),
    "contains": lambda s, args: (_require_args("contains", args, 1) or args[0] in s),
    "replace": lambda s, args: (_require_args("replace", args, 2) or s.replace(args[0], args[1])),
    "split": lambda s, args: s.split(args[0]) if args else s.split(),
    "chars": lambda s, args: list(s),
    "reverse": lambda s, args: s[::-1],
    "at": lambda s, args: (_require_args("at", args, 1) or s[int(args[0])]),
}
LIST_MEMBERS = {
    "len": lambda l, args: len(l),
    "push": _list_push,
    "pop": _list_pop,
    "first": lambda l, args: l[0],
    "last": lambda l, args: l[-1],
    "at": lambda l, args: (_require_args("at", args, 1) or l[int(args[0])]),
    "reverse": lambda l, args: l[::-1],
    "join": _list_join,
}
NUMBER_MEMBERS = {
    "abs": lambda n, args: abs(n),
    "sqrt": lambda n, args: math.sqrt(n),
    "floor": lambda n, args: math.floor(n),
    "ceil": lambda n, args: math.ceil(n),
    "round": lambda n, args: round(n, int(args[0])) if args else round(n),
    "pow": lambda n, args: (_require_args("pow", args, 1) or n ** args[0]),
    "str": lambda n, args: str(n),
    "int": lambda n, args: int(n),
    "float": lambda n, args: float(n),
}
def resolve_member(obj: Any, name: str) -> Callable:
    if isinstance(obj, str):
        if name in STRING_MEMBERS:
            return STRING_MEMBERS[name]
    elif isinstance(obj, list):
        if name in LIST_MEMBERS:
            return LIST_MEMBERS[name]
    elif isinstance(obj, (int, float)):
        if name in NUMBER_MEMBERS:
            return NUMBER_MEMBERS[name]
    type_name = type(obj).__name__
    raise AttributeError(f"'{type_name}' has no attribute or method '{name}'")

--- src/runtime/regalloc.py ---
from src.ir.ir import Instr
from src.ir.operands import Reg
from collections import namedtuple
class LiveRange:
    def __init__(self, reg, start, end):
        self.reg = reg
        self.start = start
        self.end = end
        self.phys = None
        self.slot = None
def get_defs_uses(instr):
    if instr.op in ("LOAD_CONST", "LOAD_VAR"):
        return [instr.a], []
    elif instr.op in (
        "ADD", "SUB", "MUL", "DIV", "POW",
        "EQ", "NE", "LT", "GT", "LE", "GE", "AND",
    ):
        uses = []
        if instr.b: uses.append(instr.b)
        if instr.c: uses.append(instr.c)
        return [instr.a], uses
    elif instr.op in ("NEG", "NOT", "MOVE"):
        return [instr.a], [instr.b]
    elif instr.op == "STORE_VAR":
        return [], [instr.b]
    elif instr.op in ("PRINT",):
        return [], [instr.a]
    elif instr.op in ("JUMP", "JUMP_IF_TRUE", "JUMP_IF_FALSE"):
        return [], [instr.a] if instr.op in ("JUMP_IF_TRUE", "JUMP_IF_FALSE") else []
    elif instr.op == "SPILL_STORE":
        return [], [instr.b]
    elif instr.op == "SPILL_LOAD":
        return [instr.a], []
    elif instr.op == "CALL":
        defs = [instr.c] if instr.c else []
        uses = instr.arg_regs if hasattr(instr, 'arg_regs') else []
        return defs, uses
    elif instr.op == "CALL_BUILTIN":
        defs = [instr.c] if instr.c else []
        uses = instr.b if isinstance(instr.b, list) else ([instr.b] if instr.b else [])
        return defs, uses
    elif instr.op == "GET_ATTR":
        return [instr.a], [instr.b]
    elif instr.op == "CALL_METHOD":
        uses = [instr.b] + (instr.arg_regs if hasattr(instr, "arg_regs") else [])
        return [instr.a], uses
    elif instr.op == "RETURN":
        return [], [instr.a] if instr.a else []
    elif instr.op == "LABEL":
        return [], []
    elif instr.op == "BUILD_LIST":
        uses = instr.arg_regs if hasattr(instr, "arg_regs") else []
        return [instr.a], uses
    else:
        print(f"Warning: unknown op in regalloc: {instr.op}")
        return [], []
def compute_live_ranges(code):
    first = {}
    last = {}
    for i, instr in enumerate(code):
        defs, uses = get_defs_uses(instr)
        for r in defs + uses:
            if isinstance(r, Reg):
                first.setdefault(r, i)
                last[r] = i
    ranges = [LiveRange(r, first[r], last[r]) for r in first]
    ranges.sort(key=lambda x: x.start)
    return ranges
def pick_spill(active, current):
    candidates = active + [current]
    return max(candidates, key=lambda r: r.end)
def linear_scan_allocate(code, num_regs):
    ranges = compute_live_ranges(code)
    active = []
    free_regs = list(range(num_regs))
    new_code = []
    next_slot = 0
    def expire_old(current_start):
        nonlocal active, free_regs
        still_active = []
        for r in active:
            if r.end >= current_start:
                still_active.append(r)
            else:
                free_regs.append(r.phys)
        active[:] = still_active
    for r in ranges:
        expire_old(r.start)
        if not free_regs:
            victim = pick_spill(active, r)
            if victim is r:
                r.slot = next_slot
                next_slot += 1
                r.phys = None
                continue
            else:
                victim.slot = next_slot
                next_slot += 1
                free_regs.append(victim.phys)
                active.remove(victim)
        r.phys = free_regs.pop(0)
        active.append(r)
        active.sort(key=lambda x: x.end)
    def rewrite_operand(op):
        if isinstance(op, Reg):
            lr = range_map.get(op)
            if lr is None:
                return op
            if lr.phys is not None:
                return Reg(lr.phys)
        return op
    range_map = {r.reg: r for r in ranges}
    for instr in code:
        defs, uses = get_defs_uses(instr)
        for u in uses:
            if not isinstance(u, Reg):
                continue
            lr = range_map[u]
            if lr.slot is not None:
                new_code.append(Instr("SPILL_LOAD", lr.phys, lr.slot))
        if instr.op == "CALL_BUILTIN":
            new_instr = Instr(
                instr.op,
                rewrite_operand(instr.a),
                [rewrite_operand(r) for r in instr.b] if isinstance(instr.b, list) else rewrite_operand(instr.b),
                rewrite_operand(instr.c)
            )
        elif instr.op in ("GET_ATTR", "CALL_METHOD"):
            new_instr = Instr(
                instr.op,
                rewrite_operand(instr.a),
                rewrite_operand(instr.b),
                instr.c
            )
        elif instr.op == "BUILD_LIST":
            new_instr = Instr(
                "BUILD_LIST",
                rewrite_operand(instr.a)
            )
        else:
            new_instr = Instr(
                instr.op,
                rewrite_operand(instr.a),
                rewrite_operand(instr.b),
                rewrite_operand(instr.c)
            )
        if hasattr(instr, 'arg_regs'):
            new_instr.arg_regs = [rewrite_operand(r) for r in instr.arg_regs]
        if hasattr(instr, 'param_names'):
            new_instr.param_names = instr.param_names
        new_code.append(new_instr)
        for d in defs:
            if not isinstance(d, Reg):
                continue
            lr = range_map[d]
            if lr.slot is not None:
                new_code.append(Instr("SPILL_STORE", lr.slot, lr.phys))
    return new_code

--- src/runtime/vm.py ---
from src.frontend.token_types import *
from src.exceptions import *
from .builtins_registry import BUILTINS
from .methods import resolve_member
class VM:
    def __init__(self, num_regs):
        self.num_regs = num_regs
        self.regs = [None] * self.num_regs
        self.free_regs = list(range(self.num_regs))
        self.vars = {}
        self.stack = {}
        self.call_stack = []
        self.code = None
        self.ip = 0
        self.builtins = BUILTINS
    def dump_regs(self):
        print(f"used regs: {len([reg for reg in self.regs if reg is not None])}")
        print(f"used spills: {len(self.stack)}")
        for index, reg in enumerate(self.regs):
            if reg is not None:
                print(f"reg {index} {reg}")
        for slot, value in self.stack.items():
            print(f"spill {slot} {value}")
    def find_label(self, label_name):
        for i, instr in enumerate(self.code):
            if instr.op == "LABEL" and instr.a == label_name:
                return i
        raise LabelNotFoundError(
            message=f"Label not found: {label_name}",
            ip=self.ip
        )
    def run(self, code):
        self.code = code
        while self.ip < len(code):
            instr = code[self.ip]
            op, a, b, c = instr.op, instr.a, instr.b, instr.c
            if op == "LOAD_CONST":
                self.regs[a.id] = b.value
            elif op == "LOAD_VAR":
                self.regs[a.id] = self.vars[b]
            elif op == "STORE_VAR":
                self.vars[a] = self.regs[b.id]
            elif op == "GET_ATTR":
                obj = self.regs[b.id]
                attr_name = c
                try:
                    handler = resolve_member(obj, attr_name)
                    self.regs[a.id] = handler(obj, [])
                except AttributeError as e:
                    raise RuntimeError(
                        message=str(e),
                        ip=self.ip
                    )
            elif op == "CALL_METHOD":
                obj = self.regs[b.id]
                method_name = c
                arg_regs = getattr(instr, "arg_regs", [])
                args = [self.regs[r.id] for r in arg_regs]
                try:
                    handler = resolve_member(obj, method_name)
                    result = handler(obj, args)
                    self.regs[a.id] = result
                except AttributeError as e:
                    raise RuntimeError(
                        message=str(e),
                        ip=self.ip
                    )
                except (TypeError, NotImplementedError) as e:
                    raise RuntimeError(
                        message=str(e),
                        ip=self.ip
                    )
            elif op == "CALL":
                func_name = instr.a
                if func_name in self.builtins:
                    builtin = self.builtins[func_name]
                    arg_regs = getattr(instr, "arg_regs", [])
                    ret = builtin(self, arg_regs)
                    if hasattr(instr, "c") and instr.c:
                        self.regs[instr.c.id] = ret
                else:
                    self.call_stack.append((self.ip + 1, self.vars.copy(), b))
                    target_ip = self.find_label(a)
                    self.ip = target_ip
                    self.vars = {}
                    label_instr = code[target_ip]
                    param_names = getattr(label_instr, "param_names", [])
                    arg_regs = getattr(instr, "arg_regs", [])
                    for name, reg in zip(param_names, arg_regs):
                        self.vars[name] = self.regs[reg.id]
                    continue
            elif op == "CALL_BUILTIN":
                func_name = instr.a
                arg_regs = instr.b
                builtin = self.builtins[func_name]
                ret = builtin(self, arg_regs)
                if instr.c:
                    self.regs[instr.c.id] = ret
            elif op == "RETURN":
                ret_value = None
                if a is not None:
                    ret_value = self.regs[a.id]
                if self.call_stack:
                    self.ip, caller_vars, dest_reg = self.call_stack.pop()
                    self.vars = caller_vars
                    if ret_value is not None and dest_reg is not None:
                        self.regs[dest_reg.id] = ret_value
                    continue
                else:
                    break
            elif op == "BUILD_LIST":
                arg_regs = getattr(instr, "arg_regs", [])
                self.regs[a.id] = [self.regs[r.id] for r in arg_regs]
            elif op == "LABEL":
                pass
            elif op == "JUMP":
                self.ip = a
                continue
            elif op == "JUMP_IF_TRUE":
                if self.regs[a.id]:
                    self.ip = b
                    continue
            elif op == "JUMP_IF_FALSE":
                if not self.regs[a.id]:
                    self.ip = b
                    continue
            elif op == "MOVE":
                self.regs[a.id] = self.regs[b.id]
            elif op == "SPILL_STORE":
                self.stack[a] = self.regs[b.id]
            elif op == "SPILL_LOAD":
                self.regs[a.id] = self.stack[b]
            elif op == "ADD":
                self.regs[a.id] = self.regs[b.id] + self.regs[c.id]
            elif op == "SUB":
                self.regs[a.id] = self.regs[b.id] - self.regs[c.id]
            elif op == "MUL":
                self.regs[a.id] = self.regs[b.id] * self.regs[c.id]
            elif op == "DIV":
                self.regs[a.id] = self.regs[b.id] / self.regs[c.id]
            elif op == "POW":
                self.regs[a.id] = self.regs[b.id] ** self.regs[c.id]
            elif op == "NEG":
                self.regs[a.id] = -self.regs[b.id]
            elif op == "NOT":
                self.regs[a.id] = not self.regs[b.id]
            elif op == "EQ":
                self.regs[a.id] = self.regs[b.id] == self.regs[c.id]
            elif op == "NE":
                self.regs[a.id] = self.regs[b.id] != self.regs[c.id]
            elif op == "LT":
                self.regs[a.id] = self.regs[b.id] < self.regs[c.id]
            elif op == "GT":
                self.regs[a.id] = self.regs[b.id] > self.regs[c.id]
            elif op == "LE":
                self.regs[a.id] = self.regs[b.id] <= self.regs[c.id]
            elif op == "GE":
                self.regs[a.id] = self.regs[b.id] >= self.regs[c.id]
            elif op == "AND":
                self.regs[a.id] = self.regs[b.id] and self.regs[c.id]
            else:
                raise UnknownOpcodeError(
                    message=f"Unknown opcode {op}",
                    ip=self.ip,
                    instruction=f"{op} {instr.a} {instr.b} {instr.c}"
                )
            self.ip += 1

--- src/semantic/analyser.py ---
from src.semantic.types import *
from src.frontend.ast_nodes import *
from src.semantic.symbol_table import *
from src.exceptions import *
from src.runtime.builtins_registry import BUILTINS
class Analyser():
    def __init__(self, symbols):
        self.symbols: SymbolTable = symbols
        self.current_function = None
    def analyse(self, node):
        if isinstance(node, Module):
            for stmt in node.body:
                self.analyse(stmt)
        elif isinstance(node, Call):
            func_name = node.func.id
            if func_name in BUILTINS:
                for arg in node.args:
                    self.analyse(arg)
                return UNKNOWN
            func_name = node.func.id
            if not self.symbols.exists(func_name):
                suggestion = self.symbols.closest_match(func_name)
                hint = f" Did you mean '{suggestion}'?" if suggestion else ""
                raise UndefinedVariableError(
                    message=f"Undefined function '{func_name}'.{hint}",
                    token=node.func
                )
            sym = self.symbols.get(func_name)
            if sym["type"] != "function":
                raise TypeError(
                    message=f"'{func_name}' is not a function",
                    token=node.func
                )
            expected = sym.get("param_count")
            actual = len(node.args)
            if expected is not None and actual != expected:
                raise TypeError(
                    message=f"Function '{func_name}' expected {expected} argument(s), but {len(node.args)} given",
                    token=node.func
                )
            for arg in node.args:
                self.analyse(arg)
            return None
        elif isinstance(node, Attribute):
            self.analyse(node.obj)
            return UNKNOWN
        elif isinstance(node, MethodCall):
            self.analyse(node.obj)
            for arg in node.args:
                self.analyse(arg)
            return UNKNOWN
        elif isinstance(node, Expr):
            self.analyse(node.value)
        elif isinstance(node, Assign):
            value_type = self.analyse(node.value)
            self.symbols.define(node.target.id, value_type)
        elif isinstance(node, Name):
            if not self.symbols.exists(node.id):
                suggestion = self.symbols.closest_match(node.id)
                hint = f" Did you mean '{suggestion}'?" if suggestion else ""
                raise UndefinedVariableError(
                    message=f"Undefined variable '{node.id}'.{hint}",
                    token=node
                )
            return self.symbols.get(node.id)["type"]
        elif isinstance(node, Constant):
            value = node.value
            if isinstance(value, str):
                node.inferred_type = STRING
                return STRING
            elif isinstance(value, bool):
                node.inferred_type = BOOL
                return BOOL
            elif isinstance(value, (float, int)):
                node.inferred_type = NUMBER
                return NUMBER
        elif isinstance(node, BinOp):
            left = self.analyse(node.left)
            right = self.analyse(node.right)
            if isinstance(left, UnknownType):
                left = right
                node.left.inferred_type = right
            if isinstance(right, UnknownType):
                right = left
                node.right.inferred_type = left
            if not left.supports_binary(node.op, right):
                raise TypeError(
                    message=f"Operator '{node.op}' not supported between {left} and {right}",
                    token=node
                )
            node.inferred_type = left
            return left
        elif isinstance(node, If):
            test_type = self.analyse(node.test)
            if test_type not in (BOOL, UNKNOWN) and test_type is not None:
                raise TypeError(
                    message="If condition must be boolean",
                    token=node
                )
            for stmt in node.body:
                self.analyse(stmt)
            if node.orelse:
                for stmt in node.orelse:
                    self.analyse(stmt)
        elif isinstance(node, Compare):
            left = self.analyse(node.left)
            right = self.analyse(node.comparators[0])
            if not left.is_compatible(right):
                raise TypeError(
                    message=f"Cannot compare {left} with {right}",
                    token=node
                )
            node.inferred_type = BOOL
            return BOOL
        elif isinstance(node, FunctionDef):
            self.symbols.define(node.name, {
                "type": "function",
                "param_count": len(node.args),
                "params": node.args
            })
            self.symbols.enter_scope()
            old_fn = self.current_function
            self.current_function = node
            for arg in node.args:
                self.symbols.define(arg, UNKNOWN)
            for stmt in node.body.statements:
                self.analyse(stmt)
            self.current_function = old_fn
            self.symbols.exit_scope()
        elif isinstance(node, Return):
            if self.current_function is None:
                raise SemanticError(
                    message="Return outside function",
                    token= node
                )
            if node.value:
                return_type = self.analyse(node.value)
            else:
                return_type = NUMBER
            return return_type
        elif isinstance(node, While):
            test_type = self.analyse(node.test)
            if test_type not in (BOOL, UNKNOWN) and test_type is not None:
                raise TypeError(
                    message="While condition must be boolean",
                    token=node
                )
            for stmt in node.body:
                self.analyse(stmt)
        elif isinstance(node, For):
            start_type = self.analyse(node.start)
            end_type = self.analyse(node.end)
            if start_type != NUMBER or end_type != NUMBER:
                raise TypeError(
                    message="For loop start and end must be numbers",
                    token=node
                )
            self.symbols.define(node.target.id, NUMBER)
            for stmt in node.body:
                self.analyse(stmt)
        elif isinstance(node, List):
            element_types = [self.analyse(element) for element in node.elements]
            if element_types and all(t == element_types[0] for t in element_types):
                node.inferred_type = ListType(element_types[0])
                return ListType(element_types[0])
            node.inferred_type = ListType(UNKNOWN)
            return ListType(UNKNOWN)
        else:
            return None

--- src/semantic/symbol_table.py ---
def levenshtein(a: str, b: str) -> int:
    if len(a) < len(b):
        a, b = b, a
    prev = list(range(len(b) + 1))
    for i, ca in enumerate(a, 1):
        curr = [i]
        for j, cb in enumerate(b, 1):
            curr.append(min(
                prev[j] + 1,
                curr[j - 1] + 1,
                prev[j - 1] + (ca != cb),
            ))
        prev = curr
    return prev[-1]
class SymbolTable():
    def __init__(self):
        self.scopes = [{}]
    def define(self, name, _type):
        if isinstance(_type, dict):
            self.scopes[-1][name] = _type
        else:
            self.scopes[-1][name] = {"type": _type}
    def exists(self, name):
        return any(name in scope for scope in self.scopes)
    def get(self, name):
        for scope in reversed(self.scopes):
            if name in scope:
                return scope[name]
        return None
    def all_names(self):
        names = set()
        for scope in self.scopes:
            names.update(scope.keys())
        return names
    def closest_match(self, name: str, max_distance: int = 2) -> str | None:
        candidates = self.all_names()
        best, best_dist = None, max_distance + 1
        for candidate in candidates:
            d = levenshtein(name, candidate)
            if d < best_dist:
                best, best_dist = candidate, d
        return best if best_dist <= max_distance else None
    def enter_scope(self):
        self.scopes.append({})
    def exit_scope(self):
        self.scopes.pop()

--- src/semantic/types.py ---
from dataclasses import dataclass
from typing import Tuple, ClassVar
@dataclass(frozen=True, slots=True)
class Type:
    name: ClassVar[str]
    def is_compatible(self, other: "Type") -> bool:
        if isinstance(other, UnknownType):
            return True
        return self == other
    def supports_binary(self, op: str, other: "Type") -> bool:
        return False
@dataclass(frozen=True)
class NumberType(Type):
    name: ClassVar[str] = "number"
    def supports_binary(self, op: str, other: "Type") -> bool:
        if op in {"+", "-", "*", "/", "^"}:
            return isinstance(other, NumberType)
        return False
@dataclass(frozen=True)
class StringType(Type):
    name: ClassVar[str] = "string"
    def supports_binary(self, op: str, other: "Type") -> bool:
        if op == "+":
            return isinstance(other, StringType)
        return False
@dataclass(frozen=True)
class BoolType(Type):
    name: ClassVar[str] = "bool"
@dataclass(frozen=True)
class ListType(Type):
    name: ClassVar[str] = "list"
    element_type: Type
@dataclass(frozen=True)
class UnknownType(Type):
    name: str = "unknown"
    def is_compatible(self, other: "Type") -> bool:
        return True
    def supports_binary(self, op: str, other: "Type") -> bool:
        return True
NUMBER = NumberType()
STRING = StringType()
BOOL = BoolType()
UNKNOWN = UnknownType()

