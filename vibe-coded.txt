--- main.py ---
from time import time

from src.frontend.lexer import Lexer
from src.frontend.parser import Parser
from src.semantic.analyser import Analyser, SymbolTable
from src.optimiser.optimiser import Optimiser
from src.ir.generator import IRGenerator
from src.runtime.regalloc import linear_scan_allocate
from src.runtime.vm import VM

from src.ir.operands import Reg, Imm

code = """
for i in 0..3:
    print(i)
"""

start = time()

lexer = Lexer(code)
tokens = lexer.get_tokens()
print(tokens)

parser = Parser(tokens)
tree = parser.parse()
parser.dump(tree)

symbol_table = SymbolTable()
semantic_analysis = Analyser(symbol_table)
semantic_analysis.analyse(tree)

optimiser = Optimiser()
tree = optimiser.optimize(tree)
parser.dump(tree)

ir_generator = IRGenerator()
ir_generator.generate(tree)
ir_generator.ir.dump()

num_regs = 1024
allocated = linear_scan_allocate(ir_generator.ir.code, num_regs=num_regs)

def fmt(x):
    if isinstance(x, Reg):
        return f"r{x.id}"
    if isinstance(x, Imm):
        return x.value
    return x
for i, instr in enumerate(allocated):
    print(f"realloc{i} {instr.op} {fmt(instr.a)} {fmt(instr.b)} {fmt(instr.c)}") #:04 to pad to 4 0's

vm = VM(num_regs=num_regs)
vm.code = allocated
start_ip = vm.find_label("__main__")
vm.ip = start_ip
vm.run(allocated)
vm.dump_regs()

print(f"took {time() - start} secs")

--- src/frontend/ast_nodes.py ---
from dataclasses import dataclass
from typing import List, Optional, Any

class AST():
    inferred_type = None

@dataclass
class Module():
    body: List[AST]

@dataclass
class Call(AST):
    func: AST
    args: List[AST]

@dataclass
class Assign(AST):
    target: AST
    value: AST

@dataclass
class Expr(AST):
    value: AST

@dataclass
class Name(AST):
    id: str

@dataclass
class Constant(AST):
    value: Any

@dataclass
class BinOp(AST):
    left: AST
    op: str
    right: AST

@dataclass
class UnOp(AST):
    op: str
    operand: AST

@dataclass
class If(AST):
    test: AST
    body: List[AST]
    orelse: Optional[List[AST]] = None

@dataclass
class Compare(AST):
    left: AST
    op: str
    comparators: List[AST]

@dataclass
class FunctionDef(AST):
    name: str
    args: list[str]
    body: list[AST]

@dataclass
class While(AST):
    test: AST
    body: list[AST]

@dataclass
class For(AST):
    target: Name
    start: AST
    end: AST
    body: list[AST]

--- src/frontend/lexer.py ---
from src.frontend.tokens import *

class Lexer():
    def __init__(self, text):
        self.text = text
        self.pos = 0
        self.current_char = self.text[self.pos] if self.text else None
        self.indents = [0]
    
    def advance(self):
        self.pos += 1
        
        if self.pos < len(self.text):
            self.current_char = self.text[self.pos]
        else:
            self.current_char = None
    
    def skip_whitespace(self):
        while self.current_char and self.current_char in " \t":
            self.advance()
    
    def peek(self):
        if self.pos + 1 < len(self.text):
            return self.text[self.pos + 1]
        return None
    
    def handle_indentation(self, tokens):
        count = 0
        while self.current_char == " ":
            count += 1
            self.advance()

        if self.current_char == "\n":
            return

        if count > self.indents[-1]:
            self.indents.append(count)
            tokens.append(Token(tt_indent))
        else:
            while count < self.indents[-1]:
                self.indents.pop()
                tokens.append(Token(tt_dedent))
    
    # had to crack this like the alan turing cracked cyphertext
    def number(self):
        num_str = ""
        dot_count = 0
        
        while self.current_char and (self.current_char.isdigit() or self.current_char == "."):
            if self.current_char == ".":
                if dot_count == 1:
                    break
                
                dot_count += 1
                num_str += "."
            else:
                num_str += self.current_char
            
            self.advance()
        
        if dot_count == 0:
            return Token(tt_int, int(num_str))
        else:
            return Token(tt_float, float(num_str))
    
    def string(self):
        string_val = ""
        quote_char = self.current_char
        self.advance() # skip opening quote
        
        while self.current_char and self.current_char != quote_char:
            string_val += self.current_char
            self.advance()
        
        self.advance()
        
        return Token(tt_string, string_val)
    
    def name(self):
        name_str = ""

        while self.current_char and (self.current_char.isalnum() or self.current_char == "_"):
            name_str += self.current_char
            self.advance()

        tok_type = keywords.get(name_str, tt_name)

        if tok_type == tt_name:
            return Token(tok_type, name_str)
        else:
            return Token(tok_type)
    
    def get_tokens(self):
        tokens = []
        
        while self.current_char is not None:
            if self.current_char == "\n":
                self.advance()
                tokens.append(Token(tt_newline))
                self.handle_indentation(tokens)
            
            elif self.current_char.isspace():
                self.skip_whitespace()
            
            elif self.current_char == "." and self.peek() == ".":
                self.advance()
                self.advance()
                tokens.append(Token(tt_range))
            
            elif self.current_char == "!" and self.peek() == "=":
                self.advance()
                self.advance()
                tokens.append(Token(tt_ne))
            elif self.current_char == "=" and self.peek() == "=":
                self.advance()
                self.advance()
                tokens.append(Token(tt_ee))
            elif self.current_char == "<" and self.peek() == "=":
                self.advance()
                self.advance()
                tokens.append(Token(tt_le))
            elif self.current_char == ">" and self.peek() == "=":
                self.advance()
                self.advance()
                tokens.append(Token(tt_ge))
            elif self.current_char == ">":
                self.advance()
                tokens.append(Token(tt_greater))
            elif self.current_char == "<":
                self.advance()
                tokens.append(Token(tt_less))
            
            elif self.current_char in single_char_tokens:
                tok_type = single_char_tokens[self.current_char]
                tokens.append(Token(tok_type))
                self.advance()
            
            elif self.current_char.isdigit():
                tokens.append(self.number())
            
            elif self.current_char.isalpha() or self.current_char == "_":
                tokens.append(self.name())
            
            elif self.current_char in "\"'":
                tokens.append(self.string())
            
            else:
                raise Exception(f"Illegal character: {self.current_char}")
        
        while len(self.indents) > 1:
            self.indents.pop()
            tokens.append(Token(tt_dedent))
        
        tokens.append(Token(tt_eof))
        return tokens

--- src/frontend/parser.py ---
from src.frontend.tokens import *
from src.frontend.ast_nodes import *

class Parser():
    def __init__(self, tokens):
        self.tokens = tokens
        self.pos = 0
        self.current_token = self.tokens[self.pos]
    
    def advance(self):
        self.pos += 1
        
        if self.pos < len(self.tokens):
            self.current_token = self.tokens[self.pos]
        else:
            self.current_token = Token("EOF")
    
    def peek(self):
        if self.pos + 1 < len(self.tokens):
            return self.tokens[self.pos + 1]
        return None
    
    def skip_newlines(self):
        while self.current_token.type == "NEWLINE":
            self.advance()
    
    def parse(self):
        body = []

        while self.current_token.type != "EOF":
            self.skip_newlines()
            if self.current_token.type == "EOF":
                break
            body.append(self.statement())

        return Module(body)
    
    def statement(self):
        if self.current_token.type == "PRINT":
            return self.parse_print()
        elif self.current_token.type == "IF":
            return self.parse_if()
        elif self.current_token.type == "NAME":
            if self.peek() and self.peek().type == "LPAREN":
                return self.parse_call()
            elif self.peek() and self.peek().type == "EQ":
                return self.parse_assign()
            else:
                return Expr(Name(self.current_token.value))
        elif self.current_token.type == "FN":
            return self.parse_function()
        elif self.current_token.type == "WHILE":
            return self.parse_while()
        elif self.current_token.type == "FOR":
            return self.parse_for()
        else:
            return Expr(self.parse_expr())
    
    def parse_print(self):
        # CONSUME
        self.advance()
        if self.current_token.type != "LPAREN":
            raise Exception("Expected '(' after print")
        self.advance()
        
        expr_node = self.parse_expr()
        
        if self.current_token.type != "RPAREN":
            raise Exception("Expected ')' after print argument")
        self.advance()
        
        return Call(
            func=Name("print"), # because it makes the interpreter happy
            args=[expr_node]
        )
    
    def parse_if(self):
        self.advance()  # skip 'if'
        test = self.parse_expr()

        if self.current_token.type != "COLON":
            raise Exception("Expected ':' after if condition")
        self.advance()

        if self.current_token.type != "NEWLINE":
            raise Exception("Expected newline after ':'")
        self.advance()

        if self.current_token.type != "INDENT":
            raise Exception("Expected indent")
        self.advance()

        body = []

        while True:
            self.skip_newlines()
            if self.current_token.type == "DEDENT":
                break
            body.append(self.statement())

        if self.current_token.type == "DEDENT" and self.peek() and self.peek().type == "ELSE":
            self.advance()      # DEDENT
            self.advance()      # ELSE

            if self.current_token.type != "COLON":
                raise Exception("Expected ':' after else")
            self.advance()

            if self.current_token.type != "NEWLINE":
                raise Exception("Expected newline after ':'")
            self.advance()

            if self.current_token.type != "INDENT":
                raise Exception("Expected indent in else block")
            self.advance()  # consume INDENT

            else_body = []
            while True:
                self.skip_newlines()
                if self.current_token.type == "DEDENT":
                    break
                else_body.append(self.statement())
            self.advance()  # consume DEDENT at end of else
            return If(test, body, else_body)
        else:
            self.advance()  # consume DEDENT
            return If(test, body)
    
    def parse_assign(self):
        name_token = self.current_token
        self.advance()
        
        if self.current_token.type != "EQ":
            raise Exception("Expected '=' after variable name")
        self.advance()
        
        value_node = self.parse_expr()
        
        return Assign(
            target=Name(name_token.value),
            value=value_node
        )
    
    def parse_comparison(self):
        left = self.parse_binop()
        comparators = []
        ops = []

        while self.current_token.type in ("EE","NE","LESS","GREATER","LE","GE"):
            ops.append(self.current_token.type)
            self.advance()
            comparators.append(self.parse_binop())

        if ops:
            # adjust AST if needed
            return Compare(left, ops[0], comparators)

        return left
    
    def parse_logic_or(self):
        left = self.parse_logic_and()
        
        while self.current_token.type == "OR":
            self.advance()
            right = self.parse_logic_and()
            left = BinOp(left, "or", right)
        
        return left

    def parse_logic_and(self):
        left = self.parse_comparison()
        
        while self.current_token.type == "AND":
            self.advance()
            right = self.parse_comparison()
            left = BinOp(left, "and", right)
        
        return left
    
    # why?
    #  for hotswapping past-josh, obviously...
    def parse_expr(self):
        return self.parse_logic_or()
    
    def parse_binop(self, min_prec=0):
        left = self.parse_unary()
        
        while True:
            op_token = self.current_token
            
            if op_token.type in ("PLUS", "MINUS", "MUL", "DIV", "POW"):
                prec = self.get_precedence(op_token)
                
                if prec < min_prec:
                    break
                self.advance()
                
                right = self.parse_binop(prec+1)
                left = BinOp(
                    left=left,
                    op=self.token_to_op(op_token),
                    right=right
                )

            else:
                break
        
        return left
    
    def parse_unary(self):
        tok = self.current_token
        if tok.type in ("PLUS", "MINUS"):
            self.advance()
            return UnOp(op=self.token_to_op(tok), operand=self.parse_unary())
        elif tok.type == "NOT":
            self.advance()
            return UnOp(op="not", operand=self.parse_unary())
        else:
            return self.parse_primary()
    
    def parse_primary(self):
        tok = self.current_token
        
        if tok.type == "INT" or tok.type == "FLOAT":
            self.advance()
            return Constant(tok.value)
        
        elif tok.type == "STRING":
            self.advance()
            return Constant(tok.value)
        
        elif tok.type == "NAME":
            self.advance()
            return Name(tok.value)

        elif tok.type == "LPAREN":
            self.advance()
            if self.current_token.type == "RPAREN":
                expr = Constant(None)
            else:
                expr = self.parse_expr()
            
            if self.current_token.type != "RPAREN":
                raise Exception("Expected ')' after expression")
            self.advance()
            return expr
        
        elif tok.type == "TRUE":
            self.advance()
            return Constant(True)

        elif tok.type == "FALSE":
            self.advance()
            return Constant(False)
        
        else:
            raise Exception(f"Unexpected token: {tok}")
    
    def parse_function(self):
        self.advance() # skip fn
        
        if self.current_token.type != "NAME":
            raise Exception("Expected function name")
        func_name = self.current_token.value
        self.advance()
        
        if self.current_token.type != "LPAREN":
            raise Exception("Expected '(' after function name")
        self.advance()  # skip '('

        # parse argument names (can be empty)
        args = []
        if self.current_token.type != "RPAREN":
            while True:
                if self.current_token.type != "NAME":
                    raise Exception("Expected argument name")
                args.append(self.current_token.value)
                self.advance()
                if self.current_token.type == "RPAREN":
                    break
                elif self.current_token.type == "COMMA":
                    self.advance()
                else:
                    raise Exception("Expected ',' or ')' in argument list")

        self.advance()  # skip )
        
        if self.current_token.type != "COLON":
            raise Exception("Expected ':' after function header")
        self.advance()
        
        if self.current_token.type != "NEWLINE":
            raise Exception("Expected newline after ':'")
        self.advance()
        
        if self.current_token.type != "INDENT":
            raise Exception("Expected indent in function body")
        self.advance()
        
        body = []
        while self.current_token.type != "DEDENT":
            self.skip_newlines()
            if self.current_token.type == "DEDENT":
                break
            body.append(self.statement())
        
        self.advance()
        return FunctionDef(func_name, args, body)
    
    def parse_while(self):
        self.advance()  # skip 'while'
        test = self.parse_expr()

        if self.current_token.type != "COLON":
            raise Exception("Expected ':' after while condition")
        self.advance()

        if self.current_token.type != "NEWLINE":
            raise Exception("Expected newline after ':'")
        self.advance()

        if self.current_token.type != "INDENT":
            raise Exception("Expected indent in while body")
        self.advance()

        body = []
        while self.current_token.type != "DEDENT":
            self.skip_newlines()
            if self.current_token.type == "DEDENT":
                break
            body.append(self.statement())

        self.advance()  # consume DEDENT
        return While(test, body)
    
    def parse_call(self):
        func_name = self.current_token.value
        self.advance()  # skip function name

        if self.current_token.type != "LPAREN":
            raise Exception("Expected '(' in function call")
        self.advance()  # skip '('

        args = []
        if self.current_token.type != "RPAREN":
            while True:
                args.append(self.parse_expr())
                if self.current_token.type == "COMMA":
                    self.advance()
                elif self.current_token.type == "RPAREN":
                    break
                else:
                    raise Exception("Expected ',' or ')' in argument list")
        self.advance()  # skip ')'
        return Call(Name(func_name), args)

    def parse_for(self):
        self.advance()  # skip 'for'

        if self.current_token.type != "NAME":
            raise Exception("Expected loop variable name")
        loop_var = Name(self.current_token.value)
        self.advance()

        if self.current_token.type != "IN":
            raise Exception("Expected 'in' in for loop")
        self.advance()

        start = self.parse_expr()

        if self.current_token.type != "RANGE":
            raise Exception("Expected '..' in for loop")
        self.advance()

        end = self.parse_expr()

        if self.current_token.type != "COLON":
            raise Exception("Expected ':' after for header")
        self.advance()

        if self.current_token.type != "NEWLINE":
            raise Exception("Expected newline after ':'")
        self.advance()

        if self.current_token.type != "INDENT":
            raise Exception("Expected indent in for body")
        self.advance()

        body = []
        while self.current_token.type != "DEDENT":
            self.skip_newlines()
            if self.current_token.type == "DEDENT":
                break
            body.append(self.statement())

        self.advance()  # consume DEDENT
        return For(loop_var, start, end, body)
    
    def token_to_op(self, token):
        mapping = {
            "PLUS": "+",
            "MINUS": "-",
            "MUL": "*",
            "DIV": "/",
            "POW": "^"
        }
        
        return mapping[token.type]
    
    # if i have to spell "precedence" again
    # i will literally light my codebase on fire
    def get_precedence(self, token):
        prec = {
            "PLUS": 1,
            "MINUS": 1,
            "MUL": 2,
            "DIV": 2,
            "POW": 3
        }
        
        return prec[token.type]
    
    # my beloved dump function, i love this piece of scrap
    def dump(self, node, indent=0):
        pad = "  " * indent

        if isinstance(node, Module):
            print(f"{pad}Module")
            for stmt in node.body:
                self.dump(stmt, indent + 1)
        
        elif isinstance(node, Expr):
            print(f"{pad}Expr")
            self.dump(node.value, indent + 1)
        
        elif isinstance(node, Call):
            print(f"{pad}Call")
            self.dump(node.func, indent + 1)
            for arg in node.args:
                self.dump(arg, indent + 1)
        
        elif isinstance(node, Name):
            print(f"{pad}Name({node.id})")
        
        elif isinstance(node, Constant):
            print(f"{pad}Constant({node.value})")
        
        elif isinstance(node, Assign):
            print(f"{pad}Assign")
            self.dump(node.target, indent + 1)
            self.dump(node.value, indent + 1)
        
        elif isinstance(node, BinOp):
            print(f"{pad}BinaryOp({node.op})")
            self.dump(node.left, indent + 1)
            self.dump(node.right, indent + 1)
        
        elif isinstance(node, UnOp):
            print(f"{pad}UnaryOp({node.op})")
            self.dump(node.operand, indent + 1)
        
        elif isinstance(node, If):
            print(f"{pad}If")
            self.dump(node.test, indent + 1)
            print(f"{pad}  Body:")
            for line in node.body:
                self.dump(line, indent + 2)
            if node.orelse:
                print(f"{pad}  Else:")
                for line in node.orelse:
                    self.dump(line, indent + 2)
        
        elif isinstance(node, Compare):
            print(f"{pad}Compare({node.op})")
            self.dump(node.left, indent + 1)
            for comparator in node.comparators:
                self.dump(comparator, indent + 1)
        
        elif isinstance(node, FunctionDef):
            print(f"{pad}FunctionDef({node.name})")
            print(f"{pad}  Args:")
            for arg in node.args:
                self.dump(arg, indent + 2)
            
            print(f"{pad}  Body:")
            for something in node.body: # chat remind me to change this
                self.dump(something, indent + 2)
        
        elif isinstance(node, While):
            print(f"{pad}While")
            self.dump(node.test, indent + 1)
            
            print(f"{pad}  Body:")
            for something in node.body: # chat also remind me to change this
                self.dump(something, indent + 2)
        
        else:
            print(f"{pad}{node}")

--- src/frontend/tokens.py ---
tt_int = "INT"
tt_float = "FLOAT"
tt_string = "STRING"
tt_name = "NAME"
tt_plus = "PLUS"
tt_minus = "MINUS"
tt_mul = "MUL"
tt_div = "DIV"
tt_pow = "POW"
tt_lparen = "LPAREN"
tt_rparen = "RPAREN"
tt_eq = "EQ"
tt_bang = "BANG"
tt_less = "LESS"
tt_greater = "GREATER"
tt_ne = "NE"
tt_ee = "EE"
tt_le = "LE"
tt_ge = "GE"
tt_comma = "COMMA"
tt_colon = "COLON"
tt_newline = "NEWLINE"
tt_indent = "INDENT"
tt_dedent = "DEDENT"
tt_eof = "EOF"
tt_if = "IF"
tt_else = "ELSE"
tt_print = "PRINT"
tt_and = "AND"
tt_or = "OR"
tt_not = "NOT"
tt_true = "TRUE"
tt_false = "FALSE"
tt_fn = "FN"
tt_while = "WHILE"
tt_for = "FOR"
tt_dot = "."
tt_in = "IN"
tt_range = "RANGE"

keywords = {
    "if": tt_if,
    "else": tt_else,
    "print": tt_print,
    "and": tt_and,
    "or": tt_or,
    "not": tt_not,
    "true": tt_true,
    "false": tt_false,
    "fn": tt_fn, # functions
    "while": tt_while,
    "for": tt_for,
    "in": tt_in
}

single_char_tokens = {
    "+": tt_plus,
    "-": tt_minus,
    "*": tt_mul,
    "/": tt_div,
    "^": tt_pow,
    "(": tt_lparen,
    ")": tt_rparen,
    "=": tt_eq,
    "!": tt_bang,
    "<": tt_less,
    ">": tt_greater,
    ",": tt_comma,
    ":": tt_colon,
    ".": tt_dot
}

binops = {
    "+": "ADD",
    "-": "SUB",
    "*": "MUL",
    "/": "DIV",
    "^": "POW"
}

cmp = {
    "EE": "EQ",
    "NE": "NE",
    "LESS": "LT",
    "GREATER": "GT",
    "LE": "LE",
    "GE": "GE"
}

class Token():
    def __init__(self, _type, value=None):
        self.type = _type
        self.value = value
        
    def __repr__(self):
        if self.value is not None:
            return f"{self.type}:{self.value}"
        return self.type

--- src/ir/generator.py ---
from src.frontend.ast_nodes import *
from src.frontend.tokens import *
from src.ir.ir import IR, Instr
from src.ir.operands import Imm

class IRGenerator:
    def __init__(self):
        self.ir = IR()
    
    def generate(self, node):
        method = f"gen_{type(node).__name__}"
        return getattr(self, method)(node)
    
    def gen_Module(self, node):
        self.ir.emit("LABEL", "__main__")
        
        # first generate top-level statements
        for stmt in node.body:
            if not isinstance(stmt, FunctionDef):
                self.generate(stmt)

        # jump over function definitions so we don't fall into them
        jmp = len(self.ir.code)
        self.ir.emit("JUMP", None)

        # then generate function definitions
        for stmt in node.body:
            if isinstance(stmt, FunctionDef):
                self.generate(stmt)
        
        # patch the jump to land here (after all functions)
        self.ir.code[jmp].a = len(self.ir.code)
    
    def gen_Expr(self, node):
        return self.generate(node.value)
    
    def gen_Constant(self, node):
        r = self.ir.new_reg()
        self.ir.emit("LOAD_CONST", r, Imm(node.value))
        return r
    
    def gen_Name(self, node):
        r = self.ir.new_reg()
        self.ir.emit("LOAD_VAR", r, node.id)
        return r
    
    def gen_Assign(self, node):
        value_reg = self.generate(node.value)
        self.ir.emit("STORE_VAR", node.target.id, value_reg)
    
    def gen_Call(self, node):
        if node.func.id == "print":
            arg_regs = [self.generate(a) for a in node.args]
            self.ir.emit("PRINT", arg_regs[0])
            return None
        else:
            arg_regs = [self.generate(a) for a in node.args]
            instr = Instr("CALL", node.func.id)
            instr.arg_regs = arg_regs
            instr.param_names = []  # will be resolved at runtime from FunctionDef label
            self.ir.code.append(instr)
            return None
    
    # uses backpatching
    def gen_If(self, node):
        test = self.generate(node.test)

        jmp_false = len(self.ir.code)
        self.ir.emit("JUMP_IF_FALSE", test, None)

        for stmt in node.body:
            self.generate(stmt)

        if node.orelse:
            jmp_end = len(self.ir.code)
            self.ir.emit("JUMP", None)

            self.ir.code[jmp_false].b = len(self.ir.code)

            for stmt in node.orelse:
                self.generate(stmt)

            self.ir.code[jmp_end].a = len(self.ir.code)
        else:
            self.ir.code[jmp_false].b = len(self.ir.code)
    
    # here be dragons
    # honestly tho, i havent a clue whats going on, but all i know
    # is that you can now do:
    #   a < b < c
    def gen_Compare(self, node):
        left = self.generate(node.left)

        result = None
        current_left = left

        for comp in node.comparators:
            right = self.generate(comp)
            dest = self.ir.new_reg()
            
            # safeguards against idiots using wrongs ops (me)
            opcode = cmp.get(node.op)
            if not opcode:
                raise RuntimeError(f"Unsupported comparison {node.op}")
            self.ir.emit(opcode, dest, left, right)

            if result is None:
                result = dest
            else:
                # combine with AND
                tmp = self.ir.new_reg()
                self.ir.emit("AND", tmp, result, dest)
                result = tmp

            current_left = right

        return result
    
    # binop the goat for using less regs
    def gen_BinOp(self, node):
        # short-circuit logic
        if node.op in ("and", "or"):
            return self.gen_logic(node)

        # generate left first
        left = self.generate(node.left)
        right = self.generate(node.right)

        # reuse left register as destination
        dest = left
        self.ir.emit(binops[node.op], dest, left, right)
        return dest
    
    def gen_logic(self, node):
        left = self.generate(node.left)
        dest = self.ir.new_reg()

        # copy left into dest
        self.ir.emit("MOVE", dest, left)

        if node.op == "and":
            jmp = len(self.ir.code)
            self.ir.emit("JUMP_IF_FALSE", dest, None)

            right = self.generate(node.right)
            self.ir.emit("MOVE", dest, right)

            self.ir.code[jmp].b = len(self.ir.code)

        else: # or
            jmp = len(self.ir.code)
            self.ir.emit("JUMP_IF_TRUE", dest, None)

            right = self.generate(node.right)
            self.ir.emit("MOVE", dest, right)

            self.ir.code[jmp].b = len(self.ir.code)

        return dest
    
    def gen_UnOp(self, node):
        src = self.generate(node.operand)
        dest = self.ir.new_reg()

        if node.op == "-":
            self.ir.emit("NEG", dest, src)
        elif node.op == "not":
            self.ir.emit("NOT", dest, src)
        else:
            self.ir.emit("MOVE", dest, src)

        return dest
    
    def gen_FunctionDef(self, node):
        instr = Instr("LABEL", node.name)
        instr.param_names = node.args  # store ["test_arg", ...]
        self.ir.code.append(instr)
        
        for stmt in node.body:
            self.generate(stmt)
        
        self.ir.emit("LOAD_CONST", self.ir.new_reg(), Imm(0))
        self.ir.emit("RETURN")
    
    def gen_While(self, node):
        start_label = len(self.ir.code)       # start of loop
        test_reg = self.generate(node.test)

        jmp_exit = len(self.ir.code)
        self.ir.emit("JUMP_IF_FALSE", test_reg, None)  # exit if false

        for stmt in node.body:
            self.generate(stmt)

        self.ir.emit("JUMP", start_label)      # jump back to start
        self.ir.code[jmp_exit].b = len(self.ir.code)  # patch exit
    
    def gen_For(self, node):
        # Generate start and end values
        start_reg = self.generate(node.start)
        end_reg = self.generate(node.end)

        # Store start in loop variable
        var_reg = self.ir.new_reg()
        self.ir.emit("MOVE", var_reg, start_reg)
        self.ir.emit("STORE_VAR", node.target.id, var_reg)

        loop_start = len(self.ir.code)  # start of loop

        # Load loop variable
        loop_var_reg = self.ir.new_reg()
        self.ir.emit("LOAD_VAR", loop_var_reg, node.target.id)

        # Compare with end
        cmp_reg = self.ir.new_reg()
        self.ir.emit("LT", cmp_reg, loop_var_reg, end_reg)  # loop while var < end

        jmp_exit = len(self.ir.code)
        self.ir.emit("JUMP_IF_FALSE", cmp_reg, None)

        # Generate loop body
        for stmt in node.body:
            self.generate(stmt)

        # Increment loop variable
        self.ir.emit("LOAD_VAR", var_reg, node.target.id)
        one_reg = self.ir.new_reg()
        self.ir.emit("LOAD_CONST", one_reg, Imm(1))
        self.ir.emit("ADD", var_reg, var_reg, one_reg)
        self.ir.emit("STORE_VAR", node.target.id, var_reg)

        # Jump back to start
        self.ir.emit("JUMP", loop_start)
        self.ir.code[jmp_exit].b = len(self.ir.code)

--- src/ir/ir.py ---
from src.ir.operands import Reg, Imm
from dataclasses import dataclass
from typing import Any, List

@dataclass
class Instr:
    op: str
    a: Reg | Imm | None = None
    b: Reg | Imm | None = None
    c: Reg | Imm | None = None

class IR:
    def __init__(self):
        self.code: List[Instr] = []
        self.reg = 0
    
    def new_reg(self):
        r = Reg(self.reg)
        self.reg += 1
        return r
    
    def emit(self, op, a=None, b=None, c=None):
        self.code.append(Instr(op, a, b, c))
    
    # ast-dump had a child!!
    def dump(self):
        def fmt(x):
            if isinstance(x, Reg):
                return f"r{x.id}"
            if isinstance(x, Imm):
                return x.value
            return x
        
        for i, instr in enumerate(self.code):
            print(f"{i} {instr.op} {fmt(instr.a)} {fmt(instr.b)} {fmt(instr.c)}") #:04 to pad to 4 0's

--- src/ir/operands.py ---
from dataclasses import dataclass
from typing import Any

@dataclass(frozen=True)
class Reg:
    id: int

@dataclass(frozen=True)
class Imm:
    value: Any

--- src/optimiser/optimiser.py ---
from src.optimiser.passes import ConstantFolder, DeadCodeEliminator

class Optimiser:
    def __init__(self):
        self.passes = [
            ConstantFolder(),
            DeadCodeEliminator(),
        ]

    def optimize(self, tree):
        for p in self.passes:
            tree = p.run(tree)
        return tree

--- src/optimiser/passes.py ---
from src.frontend.ast_nodes import Constant, BinOp, UnOp, If

class Pass:
    def run(self, node):
        method = f"visit_{type(node).__name__}"
        return getattr(self, method, self.generic)(node)

    def generic(self, node):
        # safe guard against edge case #382
        if not hasattr(node, "__dict__"):
            return node
        
        for field, value in vars(node).items():
            if isinstance(value, list):
                new_list = []
                for v in value:
                    result = self.run(v)
                    if isinstance(result, list):
                        new_list.extend(result)
                    else:
                        new_list.append(result)
                setattr(node, field, new_list)

            elif hasattr(value, "__dict__"):
                result = self.run(value)
                setattr(node, field, result)

        return node

class ConstantFolder(Pass):
    def visit_BinOp(self, node):
        node.left = self.run(node.left)
        node.right = self.run(node.right)
        
        if isinstance(node.left, Constant) and isinstance(node.right, Constant):
            l = node.left.value
            r = node.right.value
            
            if node.op == "+": return Constant(l + r)
            if node.op == "-": return Constant(l - r)
            if node.op == "*": return Constant(l * r)
            if node.op == "/": return Constant(l / r)
            if node.op == "^": return Constant(l ** r)
            if node.op == "and": return Constant(l and r)
            if node.op == "or": return Constant(l or r)
        
        return node
    
    def visit_UnOp(self, node):
        node.operand = self.run(node.operand)
        
        if isinstance(node.operand, Constant):
            val = node.operand.value
            
            if node.op == "-":
                return Constant(-val)
            
            if node.op == "not":
                return Constant(not val)
        
        return node
    
    def visit_Compare(self, node):
        node.left = self.run(node.left)
        node.comparators = [self.run(c) for c in node.comparators]

        if isinstance(node.left, Constant) and isinstance(node.comparators[0], Constant):
            l = node.left.value
            r = node.comparators[0].value

            if node.op == "EE": return Constant(l == r)
            if node.op == "NE": return Constant(l != r)
            if node.op == "LESS": return Constant(l < r)
            if node.op == "GREATER": return Constant(l > r)
            if node.op == "LE": return Constant(l <= r)
            if node.op == "GE": return Constant(l >= r)

        return node

class DeadCodeEliminator(Pass):
    def visit_If(self, node):
        node.test = self.run(node.test)
        
        if isinstance(node.test, Constant):
            if node.test.value:
                return [self.run(stmt) for stmt in node.body]
            else:
                return [self.run(stmt) for stmt in (node.orelse or [])]
        
        node.body = [self.run(s) for s in node.body]
        
        if node.orelse:
            node.orelse = [self.run(s) for s in node.orelse]
        
        return node

--- src/runtime/regalloc.py ---
from src.ir.ir import Instr
from src.ir.operands import Reg
from collections import namedtuple

# Live range structure
class LiveRange:
    def __init__(self, reg, start, end):
        self.reg = reg       # virtual register
        self.start = start   # first instruction index
        self.end = end       # last instruction index
        self.phys = None     # physical register assigned
        self.slot = None

# Compute defs and uses per opcode
def get_defs_uses(instr):
    if instr.op in ("LOAD_CONST", "LOAD_VAR"):
        return [instr.a], []
    elif instr.op in ("ADD","SUB","MUL","DIV","POW"):
        return [instr.a], [instr.b, instr.c]
    elif instr.op in ("NEG","NOT","MOVE"):
        return [instr.a], [instr.b]
    elif instr.op == "STORE_VAR":
        return [], [instr.b]
    elif instr.op in ("PRINT",):
        return [], [instr.a]
    elif instr.op in ("JUMP", "JUMP_IF_TRUE", "JUMP_IF_FALSE"):
        return [], [instr.a] if instr.op == "JUMP_IF_TRUE" or instr.op == "JUMP_IF_FALSE" else []
    elif instr.op == "SPILL_STORE":
        return [], [instr.b]
    elif instr.op == "SPILL_LOAD":
        return [instr.a], []
    else:
        return [], []

# Compute live ranges based on defs/uses
def compute_live_ranges(code):
    first = {}
    last = {}

    for i, instr in enumerate(code):
        defs, uses = get_defs_uses(instr)
        for r in defs + uses:
            if isinstance(r, Reg):
                first.setdefault(r, i)
                last[r] = i

    ranges = [LiveRange(r, first[r], last[r]) for r in first]
    ranges.sort(key=lambda x: x.start)
    return ranges

def pick_spill(active, current):
    candidates = active + [current]
    return max(candidates, key=lambda r: r.end)

def linear_scan_allocate(code, num_regs):
    ranges = compute_live_ranges(code)
    active = []
    free_regs = list(range(num_regs))
    new_code = []
    
    next_slot = 0

    def expire_old(current_start):
        nonlocal active, free_regs
        still_active = []
        for r in active:
            if r.end >= current_start:
                still_active.append(r)
            else:
                free_regs.append(r.phys)
        active[:] = still_active

    for r in ranges:
        expire_old(r.start)
        if not free_regs:
            victim = pick_spill(active, r)

            if victim is r:
                r.slot = next_slot
                next_slot += 1
                r.phys = None
                continue
            else:
                # spill an active range
                victim.slot = next_slot
                next_slot += 1

                free_regs.append(victim.phys)
                active.remove(victim)
        
        r.phys = free_regs.pop(0)
        active.append(r)
        active.sort(key=lambda x: x.end)
    
    def rewrite_operand(op):
        if isinstance(op, Reg):
            lr = range_map[op]      # lookup virtual Reg object
            if lr.phys is not None:
                return Reg(lr.phys)
        return op
    
    # Rewrite registers in a new IR list
    range_map = {r.reg: r for r in ranges}
    for instr in code:

        defs, uses = get_defs_uses(instr)

        # reload uses
        for u in uses:
            if not isinstance(u, Reg):
                continue
            lr = range_map[u]
            if lr.slot is not None:
                new_code.append(Instr("SPILL_LOAD", lr.phys, lr.slot))

        new_instr = Instr(
            instr.op,
            rewrite_operand(instr.a),
            rewrite_operand(instr.b),
            rewrite_operand(instr.c)
        )
        
        # Carry over CALL/LABEL metadata, rewriting virtual regs in arg_regs
        if hasattr(instr, 'arg_regs'):
            new_instr.arg_regs = [rewrite_operand(r) for r in instr.arg_regs]
        if hasattr(instr, 'param_names'):
            new_instr.param_names = instr.param_names

        new_code.append(new_instr)

        # spill defs
        for d in defs:
            if not isinstance(d, Reg):
                continue
            lr = range_map[d]
            if lr.slot is not None:
                new_code.append(Instr("SPILL_STORE", lr.slot, lr.phys))

    return new_code

--- src/runtime/vm.py ---
# past-josh: PLEASE FOR THE LOVE OF GOD REFACTOR TO REGISTER-BASED!!
# future-josh: your wish is my command
class VM:
    def __init__(self, num_regs):
        self.num_regs = num_regs
        self.regs = [None] * self.num_regs
        self.free_regs = list(range(self.num_regs))
        self.vars = {}
        self.stack = {}
        self.call_stack = [] # (ip, locals)
        self.code = None # to be set in /main.py
        self.ip = 0 # instruction pointer
    
    def dump_regs(self): # simple dump debugger
        print(f"used regs: {len([reg for reg in self.regs if reg is not None])}")
        print(f"used spills: {len(self.stack)}")
        
        for index, reg in enumerate(self.regs): # prints every used reg
            if reg is not None:
                print(f"reg {index} {reg}")
        
        for slot, value in self.stack.items(): # prints every spill var in stack
            print(f"spill {slot} {value}")
    
    def find_label(self, label_name): # for functions / gen calls
        for i, instr in enumerate(self.code):
            if instr.op == "LABEL" and instr.a == label_name:
                return i
        raise RuntimeError(f"Label not found: {label_name}")
    
    def run(self, code):
        self.ip = 0
        
        while self.ip < len(code):
            instr = code[self.ip]
            op, a, b, c = instr.op, instr.a, instr.b, instr.c
            
            if op == "LOAD_CONST":
                self.regs[a.id] = b.value
            
            elif op == "LOAD_VAR":
                self.regs[a.id] = self.vars[b]
            
            elif op == "STORE_VAR":
                self.vars[a] = self.regs[b.id]
            
            elif op == "PRINT":
                print(self.regs[a.id])
            
            elif op == "CALL":
                self.call_stack.append((self.ip + 1, self.vars.copy()))
                
                target_ip = self.find_label(a)
                self.ip = target_ip
                self.vars = {}

                # get param names from the LABEL instruction itself
                label_instr = code[target_ip]
                param_names = getattr(label_instr, "param_names", [])
                arg_regs = getattr(instr, "arg_regs", [])

                for name, reg in zip(param_names, arg_regs):
                    self.vars[name] = self.regs[reg.id]

                continue

            elif op == "RETURN":
                if self.call_stack:
                    self.ip, caller_vars = self.call_stack.pop()
                    self.vars = caller_vars
                    continue
                else:
                    # top-level RETURN: just stop execution
                    break
            
            elif op == "LABEL":
                # its literally just a label...
                # its meant to do nothing
                pass
            
            elif op == "JUMP":
                self.ip = a
                continue
            
            elif op == "JUMP_IF_TRUE":
                if self.regs[a.id]:
                    self.ip = b
                    continue
            
            elif op == "JUMP_IF_FALSE":
                if not self.regs[a.id]:
                    self.ip = b
                    continue
            
            elif op == "MOVE":
                self.regs[a.id] = self.regs[b.id]
            
            # spilling
            elif op == "SPILL_STORE":
                self.stack[a] = self.regs[b]

            elif op == "SPILL_LOAD":
                self.regs[a] = self.stack[b]
            
            # arithmetic
            elif op == "ADD":
                self.regs[a.id] = self.regs[b.id] + self.regs[c.id]

            elif op == "SUB":
                self.regs[a.id] = self.regs[b.id] - self.regs[c.id]

            elif op == "MUL":
                self.regs[a.id] = self.regs[b.id] * self.regs[c.id]

            elif op == "DIV":
                self.regs[a.id] = self.regs[b.id] / self.regs[c.id]

            elif op == "POW":
                self.regs[a.id] = self.regs[b.id] ** self.regs[c.id]

            elif op == "NEG":
                self.regs[a.id] = -self.regs[b.id]

            elif op == "NOT":
                self.regs[a.id] = not self.regs[b.id]

            # comparisons
            elif op == "EQ":
                self.regs[a.id] = self.regs[b.id] == self.regs[c.id]

            elif op == "NE":
                self.regs[a.id] = self.regs[b.id] != self.regs[c.id]

            elif op == "LT":
                self.regs[a.id] = self.regs[b.id] < self.regs[c.id]

            elif op == "GT":
                self.regs[a.id] = self.regs[b.id] > self.regs[c.id]

            elif op == "LE":
                self.regs[a.id] = self.regs[b.id] <= self.regs[c.id]

            elif op == "GE":
                self.regs[a.id] = self.regs[b.id] >= self.regs[c.id]
            
            elif op == "AND":
                self.regs[a.id] = self.regs[b.id] and self.regs[c.id]

            else:
                raise RuntimeError(f"Unknown opcode {op}")
    
            self.ip += 1

--- src/semantic/analyser.py ---
from src.semantic.types import *
from src.frontend.ast_nodes import *
from src.semantic.symbol_table import *

# message for future-josh
#  this is going to be the most confusing, awful, horrid-looking code you have ever seen,
#  so dont even bother trying to debug this pile of horse-doodoo

# future-josh here, i have to debug this now...

class Analyser():
    def __init__(self, symbols):
        self.symbols: SymbolTable = symbols
    
    def analyse(self, node):
        if isinstance(node, Module):
            for stmt in node.body:
                self.analyse(stmt)
        
        elif isinstance(node, Call):
            for arg in node.args:
                self.analyse(arg)
            
            return None
        
        # unused?
        elif isinstance(node, Expr):
            self.analyse(node.value)
        
        elif isinstance(node, Assign):
            value_type = self.analyse(node.value)
            self.symbols.define(node.target.id, value_type)
        
        elif isinstance(node, Name):
            if not self.symbols.exists(node.id):
                raise Exception(f"Undefined variable '{node.id}'")
            
            return self.symbols.get(node.id)["type"]
        
        elif isinstance(node, Constant):
            value = node.value
            
            if isinstance(value, str):
                node.inferred_type = STRING
                return STRING
            
            elif isinstance(value, bool):
                node.inferred_type = BOOL
                return BOOL
            
            elif isinstance(value, (float, int)):
                node.inferred_type = NUMBER
                return NUMBER
        
        elif isinstance(node, BinOp):
            left = self.analyse(node.left)
            right = self.analyse(node.right)

            # if left is unknown, adopt right's type
            if isinstance(left, UnknownType):
                left = right
                node.left.inferred_type = right

            if isinstance(right, UnknownType):
                right = left
                node.right.inferred_type = left

            if not left.supports_binary(node.op, right):
                raise TypeError(f"Operator '{node.op}' not supported between {left} and {right}")

            node.inferred_type = left
            return left
        
        elif isinstance(node, If):
            test_type = self.analyse(node.test)
            if test_type != BOOL:
                raise TypeError("If condition must be boolean")

            for stmt in node.body:
                self.analyse(stmt)

            if node.orelse:
                for stmt in node.orelse:
                    self.analyse(stmt)
        
        elif isinstance(node, Compare):
            left = self.analyse(node.left)
            right = self.analyse(node.comparators[0])

            if not left.is_compatible(right):
                raise TypeError(f"Cannot compare {left} with {right}")

            node.inferred_type = BOOL
            return BOOL

        elif isinstance(node, FunctionDef):
            self.symbols.define(node.name, "function")
            
            self.symbols.enter_scope() # lets just pretend this exists
            for arg in node.args:
                self.symbols.define(arg, UNKNOWN)
            for stmt in node.body:
                self.analyse(stmt)
            self.symbols.exit_scope()
        
        elif isinstance(node, While):
            test_type = self.analyse(node.test)
            if test_type != BOOL:
                raise TypeError("While condition must be boolean")
            for stmt in node.body:
                self.analyse(stmt)
        
        elif isinstance(node, For):
            start_type = self.analyse(node.start)
            end_type = self.analyse(node.end)

            if start_type != NUMBER or end_type != NUMBER:
                raise TypeError("For loop start and end must be numbers")

            self.symbols.define(node.target.id, NUMBER)

            for stmt in node.body:
                self.analyse(stmt)
        
        else:
            return None

--- src/semantic/symbol_table.py ---
class SymbolTable():
    def __init__(self):
        self.scopes = [{}]  # stack of scopes
    
    def define(self, name, _type):
        self.scopes[-1][name] = {"type": _type}
    
    def exists(self, name):
        return any(name in scope for scope in self.scopes)
    
    def get(self, name):
        for scope in reversed(self.scopes):
            if name in scope:
                return scope[name]
        return None
    
    def enter_scope(self):
        self.scopes.append({})
    
    def exit_scope(self):
        self.scopes.pop()

--- src/semantic/types.py ---
from dataclasses import dataclass
from typing import Tuple, ClassVar

@dataclass(frozen=True, slots=True)
class Type:
    name: ClassVar[str]

    def is_compatible(self, other: "Type") -> bool:
        return self == other

    def supports_binary(self, op: str, other: "Type") -> bool:
        return False

@dataclass(frozen=True)
class NumberType(Type):
    name: ClassVar[str] = "number"

    def supports_binary(self, op: str, other: "Type") -> bool:
        if op in {"+", "-", "*", "/", "^"}:
            return isinstance(other, NumberType)
        return False

@dataclass(frozen=True)
class StringType(Type):
    name: ClassVar[str] = "string"

    def supports_binary(self, op: str, other: "Type") -> bool:
        if op == "+":
            return isinstance(other, StringType)
        return False

@dataclass(frozen=True)
class BoolType(Type):
    name: ClassVar[str] = "bool"

# future proofing
@dataclass(frozen=True)
class ListType(Type):
    name: ClassVar[str] = "list"
    element_type: Type

@dataclass(frozen=True)
class UnknownType(Type):
    name: str = "unknown"

    def is_compatible(self, other: "Type") -> bool:
        return True
    
    def supports_binary(self, op: str, other: "Type") -> bool:
        # allow the operation and "become" the other type
        return True

NUMBER = NumberType()
STRING = StringType()
BOOL = BoolType()
UNKNOWN = UnknownType()

